#INSTRUCTIONS

#Config section is the only section you need to fill out before running 
#Make sure Logo_Path points to the logo file path on your computer 

import os
import re
import json
import time
import random
import requests
from typing import Dict, List, Optional
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.utils import ImageReader
from PyPDF2 import PdfMerger
from datetime import date, timedelta

# -----------------------------
# -------- CONFIG -------------
# -----------------------------
CLIENT_ID = "INSERT HERE"  # copy paste from your APS app 
CLIENT_SECRET = "INSERT HERE"  # copy paste from your APS app 
HUB_ID = "b.INSERT HERE"  # copy paste your account ID here with a "b." prefix
ACCOUNT_ID = HUB_ID.replace("b.", "")
REGION = "US"
FORM_TEMPLATE_NAME = "IN-0005A Project Weekly Report"  # must be exact in order to work 
TOKENS_FILE = "tokens.json"
OUTPUT_DIR = "INSERT HERE"  # folder to route PDF to 
COMBINED_PDF_NAME = "INSERT HERE"  # final PDF file name 
FORMDATE_LAST_N_DAYS = None  # filter by formDate (None or int)

# --- LOGO ---
LOGO_PATH = "INSERT HERE"  # file path to your logo image 
LOGO_MAX_W = 1.2 * inch      
LOGO_MAX_H = 0.40 * inch    
LOGO_PADDING_RIGHT = 0      
LOGO_PADDING_TOP = 0        

# --- PDF Layout / Table widths ---
TEXT_COL_W = 2.5 * inch
IMG_COL_W  = 3.0 * inch  # images in the table bounded to this size (keeps aspect), same as referenced photos grid logic

# --- Global Rate Limiting ---
REQUESTS_PER_MINUTE = 60   
MAX_RETRIES = 3           
BACKOFF_INITIAL = 1.0      
BACKOFF_MAX = 10.0        
JITTER = 0.25              
RESPECT_RETRY_AFTER = True 

# -----------------------------
# ---- RATE-LIMITED SESSION ---
# -----------------------------
SESSION = requests.Session()
_LAST_REQ_TS = 0.0
_MIN_INTERVAL = 60.0 / max(1, int(REQUESTS_PER_MINUTE or 1))

def rl_request(method: str, url: str, **kwargs) -> requests.Response:
    """Rate-limited request with basic exponential backoff for 429/5xx."""
    global _LAST_REQ_TS
    attempt = 0
    while True:
        now = time.time()
        wait = max(0.0, _LAST_REQ_TS + _MIN_INTERVAL - now)
        if wait > 0:
            time.sleep(wait)

        _LAST_REQ_TS = time.time()
        resp = SESSION.request(method, url, **kwargs)

        retryable = (resp.status_code == 429) or (500 <= resp.status_code < 600)
        if retryable and attempt < MAX_RETRIES:
            attempt += 1
            delay = BACKOFF_INITIAL * (2 ** (attempt - 1))
            if RESPECT_RETRY_AFTER:
                ra = resp.headers.get("Retry-After")
                if ra:
                    try:
                        delay = float(ra)
                    except Exception:
                        pass
            delay = min(BACKOFF_MAX, delay) + random.uniform(0.0, JITTER)
            time.sleep(delay)
            continue
        return resp

# -----------------------------
# -------- AUTH ---------------
# -----------------------------
def get_access_token() -> str:
    if not os.path.exists(TOKENS_FILE):
        raise RuntimeError("tokens.json missing; run your 3-legged OAuth first.")
    with open(TOKENS_FILE, "r") as f:
        rt = json.load(f)["refresh_token"]
    r = rl_request(
        "POST",
        "https://developer.api.autodesk.com/authentication/v2/token",
        data={
            "grant_type": "refresh_token",
            "refresh_token": rt,
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
        },
        timeout=45,
    )
    r.raise_for_status()
    j = r.json()
    with open(TOKENS_FILE, "w") as f:
        json.dump({"refresh_token": j["refresh_token"]}, f)
    return j["access_token"]

def H(tok: str) -> Dict[str, str]:
    return {
        "Authorization": f"Bearer {tok}",
        "Content-Type": "application/json",
        "x-ads-region": REGION,
    }

# -----------------------------
# ---- LOGO DRAWING -----------
# -----------------------------
def choose_logo_path_from_config() -> Optional[str]:
    p = (LOGO_PATH or "").strip()
    if not p:
        print("No logo set (LOGO_PATH is empty).")
        return None
    p = os.path.abspath(os.path.expanduser(p))
    if os.path.exists(p):
        return p
    print(f"Logo not found at: {p}\nCurrent working directory: {os.getcwd()}")
    return None

def make_page_logo_drawer(logo_path: Optional[str]):
    """Return a function(canvas, doc) that draws the logo (if any) on each page."""
    if not logo_path:
        return lambda canvas, doc: None
    try:
        ir = ImageReader(logo_path)
        iw, ih = ir.getSize()
    except Exception as e:
        print(f"Failed to load logo '{logo_path}': {e}")
        return lambda canvas, doc: None

    def _draw(canvas, doc):
        try:
            scale = min(LOGO_MAX_W / iw, LOGO_MAX_H / ih, 1.0)
            w = iw * scale
            h = ih * scale
            page_w, page_h = doc.pagesize
            x = page_w - doc.rightMargin - w - LOGO_PADDING_RIGHT
            y = page_h - doc.topMargin + (doc.topMargin - h) / 2 + LOGO_PADDING_TOP
            canvas.drawImage(ir, x, y, width=w, height=h, mask='auto')
        except Exception as e:
            print(f"Failed to draw logo on page: {e}")
    return _draw

# -----------------------------
# ---- PROJECT ADDRESSES ------
# -----------------------------
def get_project_addresses(tok: str) -> Dict[str, str]:
    headers = {"Authorization": f"Bearer {tok}", "Content-Type": "application/json"}
    fields = "name,addressLine1,addressLine2,city,stateOrProvince,postalCode,country"
    base_url = f"https://developer.api.autodesk.com/construction/admin/v1/accounts/{ACCOUNT_ID}/projects"
    out = {}
    url = base_url
    params = {"fields": fields}
    while url:
        r = rl_request("GET", url, headers=headers, params=params, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch project addresses: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for p in j.get("results", []):
            pid = p.get("id")
            parts = [
                p.get("addressLine1", ""),
                p.get("addressLine2", ""),
                p.get("city", ""),
                p.get("stateOrProvince", ""),
                p.get("postalCode", ""),
                p.get("country", ""),
            ]
            addr = ", ".join(x for x in parts if x and x != "N/A").strip()
            out[pid] = addr if addr else "No address available"
        url = (j.get("pagination") or {}).get("nextUrl")
        params = {}
    return out

# -----------------------------
# ------ RELATIONSHIPS --------
# -----------------------------
def rel_form_to_photos(tok: str, project_id: str, form_id: str) -> List[str]:
    base = (
        "https://developer.api.autodesk.com/bim360/relationship/v2"
        f"/containers/{project_id}/relationships:search"
        f"?domain=autodesk-construction-form&type=form&id={form_id}"
        "&withDomain=autodesk-construction-photo&withType=photo"
        "&includeDeleted=false&pageLimit=100"
    )
    ids: List[str] = []
    seen = set()
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch form relationships for form {form_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for rel in (j.get("relationships") or []):
            for e in rel.get("entities", []):
                if e.get("domain") == "autodesk-construction-photo" and e.get("type") == "photo":
                    pid = e.get("id")
                    if pid and pid not in seen:
                        ids.append(pid)
                        seen.add(pid)
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return ids

def rel_formfield_to_photos(tok: str, project_id: str) -> Dict[str, Dict[str, List[str]]]:
    base = (
        f"https://developer.api.autodesk.com/bim360/relationship/v2/containers/{project_id}/relationships:search"
        "?domain=autodesk-construction-form&type=formfield"
        "&withDomain=autodesk-construction-photo&withType=photo"
        "&includeDeleted=false&pageLimit=100"
    )
    form_field_photos: Dict[str, Dict[str, List[str]]] = {}
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch formfield relationships: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for rel in (j.get("relationships") or []):
            entities = rel.get("entities", [])
            if (
                len(entities) > 1 and
                entities[1].get("domain") == "autodesk-construction-form" and
                entities[1].get("type") == "formfield" and
                entities[0].get("domain") == "autodesk-construction-photo" and
                entities[0].get("type") == "photo"
            ):
                field_urn = entities[1].get("id")
                photo_id = entities[0].get("id")
                if not (field_urn and photo_id):
                    continue
                try:
                    form_id, field_id = field_urn.replace("urn:adsk:form.field:", "").split("/")
                    form_field_photos.setdefault(form_id, {}).setdefault(field_id, [])
                    if photo_id not in form_field_photos[form_id][field_id]:
                        form_field_photos[form_id][field_id].append(photo_id)
                except ValueError:
                    pass
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return form_field_photos

def photos_filter_by_ids(tok: str, project_id: str, ids: List[str]) -> List[dict]:
    if not ids:
        return []
    url = f"https://developer.api.autodesk.com/construction/photos/v1/projects/{project_id}/photos:filter"
    out = []
    for i in range(0, len(ids), 50):
        body = {"filter": {"id": ids[i:i+50]}, "include": ["signedUrls"], "limit": 50}
        r = rl_request("POST", url, headers=H(tok), json=body, timeout=60)
        if r.status_code != 200:
            print(f"Failed to fetch photos: {r.status_code} - {r.text}")
            continue
        out.extend((r.json() or {}).get("results", []) or [])
    return out

def pick_best_url(signed: dict) -> Optional[str]:
    for k in ("original", "full", "large", "fileUrl", "url", "medium", "thumbnail"):
        v = (signed or {}).get(k)
        if isinstance(v, str) and v.startswith("http"):
            return v
    for v in (signed or {}).values():
        if isinstance(v, str) and v.startswith("http"):
            return v
    return None

def download_photos(photos_meta: List[dict], out_dir: str, prefix: str) -> Dict[str, str]:
    os.makedirs(out_dir, exist_ok=True)
    id2path = {}
    for p in photos_meta:
        pid = p.get("id")
        signed = p.get("signedUrls") or {}
        url = pick_best_url(signed)
        if pid and url:
            local = os.path.join(out_dir, f"{prefix}_{pid}.jpg")
            try:
                rr = rl_request("GET", url, timeout=90)
                if rr.status_code != 200:
                    print(f"Failed to download photo {pid}: HTTP {rr.status_code}")
                    continue
                with open(local, "wb") as f:
                    f.write(rr.content)
                id2path[pid] = local
            except Exception as e:
                print(f"Failed to download photo {pid}: {str(e)}")
    return id2path

# -----------------------------
# ----- FORM DETAILS (fallback)
# -----------------------------
def get_form_details(tok: str, project_id: str, form_id: str) -> Optional[dict]:
    """Fallback detail fetch (only used if list form lacks answers)."""
    url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/forms/{form_id}"
    params = {"include": "customValues,pdfValues"}
    r = rl_request("GET", url, headers=H(tok), params=params, timeout=45)
    if r.status_code != 200:
        print(f"Failed to fetch form details {form_id}: {r.status_code} - {r.text}")
        return None
    j = r.json() or {}
    return j.get("data") if isinstance(j, dict) and "data" in j else j

def ensure_form_has_answers(tok: str, project_id: str, form_from_list: dict) -> dict:
    """Prefer list form; if no answers there, fetch details and merge pdfValues if present."""
    cv = form_from_list.get("customValues") or []
    if cv:
        return form_from_list
    detail = get_form_details(tok, project_id, form_from_list.get("id", ""))
    if not detail:
        return form_from_list
    if detail.get("customValues"):
        return detail
    if detail.get("pdfValues"):
        merged = dict(form_from_list)
        merged["pdfValues"] = detail["pdfValues"]
        return merged
    return form_from_list

# -----------------------------
# --------- FORMS -------------
# -----------------------------
def get_projects(tok: str) -> List[dict]:
    url = f"https://developer.api.autodesk.com/project/v1/hubs/{HUB_ID}/projects"
    projects: List[dict] = []
    next_url = url
    while next_url:
        r = rl_request("GET", next_url, headers={"Authorization": f"Bearer {tok}"}, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch projects: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        projects.extend(j.get("data", []) or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return projects

def _filter_by_formdate(forms: List[dict]) -> List[dict]:
    """Keep only forms whose formDate is within the last N days (if enabled)."""
    if not FORMDATE_LAST_N_DAYS or FORMDATE_LAST_N_DAYS <= 0:
        return forms
    cutoff = date.today() - timedelta(days=FORMDATE_LAST_N_DAYS)
    out = []
    for f in forms:
        fd = f.get("formDate")
        try:
            d = date.fromisoformat(fd) if fd else None
        except Exception:
            d = None
        if d and d >= cutoff:
            out.append(f)
    return out

def list_forms_for_template(tok: str, project_id: str, template_name: str) -> List[dict]:
    # Pull ALL forms (paginated), filter by template name client-side, then by formDate window.
    forms: List[dict] = []
    next_url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/forms"
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch forms for project {project_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        forms.extend(j.get("data") or j.get("results") or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")

    matching = [f for f in forms if (f.get("formTemplate") or {}).get("name") == template_name]
    matching = _filter_by_formdate(matching)
    return matching

def get_form_templates(tok: str, project_id: str) -> List[dict]:
    url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/form-templates?limit=50"
    out = []
    next_url = url
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if not (200 <= r.status_code < 300):
            print(f"Failed to fetch templates for project {project_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        out.extend(j.get("data") or j.get("results") or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return out

def template_by_id(templates: List[dict], template_id: str) -> Optional[dict]:
    for t in templates:
        if t.get("id") == template_id:
            return t
    return None

# -----------------------------
# ---- ANSWER MAPPING ----------
# -----------------------------
def _norm(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").strip().lower())

def build_value_indexes(custom_values: List[dict]) -> (Dict[str, object], Dict[str, object]):
    """
    Build two indexes from customValues:
      - by_id[str(itemId/fieldId)] -> raw value
      - by_label_code[normalized(label/code combos)] -> raw value
    Raw values will be converted to display strings later using template item metadata.
    """
    by_id: Dict[str, object] = {}
    by_lbl: Dict[str, object] = {}
    for cv in custom_values or []:
        # unify the raw value
        raw = None
        if "textVal" in cv and cv["textVal"] is not None:
            raw = cv["textVal"]
        elif "multilineTextVal" in cv and cv["multilineTextVal"] is not None:
            raw = cv["multilineTextVal"]
        elif "numberVal" in cv and cv["numberVal"] is not None:
            raw = str(cv["numberVal"])
        elif "dateVal" in cv and cv["dateVal"] is not None:
            raw = cv["dateVal"]
        elif "toggleVal" in cv and cv["toggleVal"] is not None:
            raw = "Yes" if cv["toggleVal"] else "No"
        elif "choiceVal" in cv and cv["choiceVal"] is not None:
            raw = cv["choiceVal"]
        elif "multiChoiceVal" in cv and cv["multiChoiceVal"] is not None:
            raw = cv["multiChoiceVal"]
        elif "value" in cv and cv["value"] is not None:
            raw = cv["value"]

        # index by id
        iid = cv.get("itemId") or cv.get("fieldId")
        if iid is not None:
            by_id[str(iid)] = raw

        # index by labels/codes when available
        lbl = cv.get("itemLabel")
        code = cv.get("itemCode")
        if lbl:
            by_lbl[_norm(lbl)] = raw
        if code:
            by_lbl[_norm(code)] = raw
        if lbl and code:
            by_lbl[_norm(f"{code} {lbl}")] = raw
            by_lbl[_norm(f"{code}{lbl}")] = raw
    return by_id, by_lbl

def build_pdfvalue_map(form: dict) -> Dict[str, str]:
    out: Dict[str, str] = {}
    for pv in (form.get("pdfValues") or []):
        name = pv.get("name")
        val = pv.get("value")
        if name:
            out[_norm(name)] = "" if val is None else str(val)
    return out

def value_to_label(item: dict, value) -> str:
    if value is None:
        return ""
    t = item.get("type", "")
    if t == "choice":
        opts = item.get("options", []) or []
        sel = next((o for o in opts if o.get("id") == value), None)
        return (sel or {}).get("label") or "N/A"
    if t == "multi_choice":
        opts = item.get("options", []) or []
        labels = [o.get("label") for o in opts if o.get("id") in (value or [])]
        return ", ".join([x for x in labels if x]) if labels else "N/A"
    return str(value)

def find_answer_for_item(item: dict, by_id: Dict[str, object], by_lbl: Dict[str, object], pdf_map: Dict[str, str]) -> str:
    """
    Resolve answer for a template item with multiple fallbacks:
      1) by item.id
      2) by label/code (normalized)
      3) by pdfValues name matching
    """
    item_id = str(item.get("id") or "")
    if item_id and item_id in by_id:
        return value_to_label(item, by_id[item_id])

    code = (item.get("code") or "").strip()
    label = (item.get("label") or "").strip()
    for cand in (code, label, (code + " " + label).strip(), (code + label).strip()):
        k = _norm(cand)
        if k and k in by_lbl:
            return value_to_label(item, by_lbl[k])

    # final fallback: pdfValues
    for cand in (code, label, (code + " " + label).strip(), (code + label).strip()):
        k = _norm(cand)
        if k and k in pdf_map and pdf_map[k]:
            return pdf_map[k]
    return ""

# -----------------------------
# --------- PDF ---------------
# -----------------------------
def make_styles():
    styles = getSampleStyleSheet()
    style_definitions = [
        {'name': 'Title', 'parent': styles.get('Heading1', styles['Normal']),
         'alignment': 1, 'fontSize': 18, 'textColor': colors.HexColor("#0055A4"), 'spaceAfter': 18},
        {'name': 'SectionHeader', 'parent': styles.get('Heading2', styles['Normal']),
         'fontSize': 14, 'textColor': colors.HexColor("#0055A4"), 'spaceAfter': 10, 'leading': 16},
        {'name': 'FormName', 'parent': styles.get('Heading2', styles['Normal']),
         'alignment': 1, 'fontSize': 14, 'textColor': colors.HexColor("#0055A4"), 'spaceAfter': 10, 'leading': 16},
        {'name': 'CenteredAddress', 'parent': styles.get('Normal', styles['Normal']),
         'alignment': 1, 'fontSize': 10, 'leading': 12, 'spaceAfter': 6},
        {'name': 'BodySmall', 'parent': styles.get('Normal', styles['Normal']),
         'fontSize': 10, 'leading': 12, 'spaceAfter': 4},
    ]
    for sd in style_definitions:
        nm = sd['name']
        if nm not in styles.byName and nm not in styles.byAlias:
            styles.add(ParagraphStyle(**sd))
    return styles

def render_form_pdf(
    project_name: str,
    project_address: str,
    form: dict,
    template: dict,
    field_photo_paths: Dict[str, List[str]],
    ref_photo_paths: List[str],
    out_path: str,
    page_decorator=None,   # draws logo/header/footer per page
) -> None:
    doc = SimpleDocTemplate(out_path, pagesize=A4, rightMargin=36, leftMargin=36, topMargin=36, bottomMargin=36)
    styles = make_styles()
    story = []

    # Header
    story.append(Paragraph(project_name, styles["Title"]))
    story.append(Paragraph(project_address or "No address available", styles["CenteredAddress"]))
    story.append(Paragraph(f"Form #{form.get('formNum', '')}: {FORM_TEMPLATE_NAME}", styles["FormName"]))
    story.append(Spacer(1, 8))

    # Build answer indexes and pdfValues map
    custom_values = form.get("customValues") or []
    by_id, by_lbl = build_value_indexes(custom_values)
    pdf_map = build_pdfvalue_map(form)
    print(f"Answer indexes: by_id={len(by_id)} by_lbl={len(by_lbl)} pdfValues={len(pdf_map)}")

    # Table data
    data = []
    section_rows: List[int] = []
    sections = (template or {}).get("sections") or []

    if not sections:
        # Fallback layout when no template sections are available
        current_section = None
        for cv in custom_values:
            sec_label = cv.get("sectionLabel") or "Section"
            if sec_label != current_section:
                data.append([Paragraph(f"<b>{sec_label}</b>", styles["SectionHeader"]), "", ""])
                section_rows.append(len(data) - 1)
                current_section = sec_label
            item_label = cv.get("itemLabel") or "Item"
            # reuse the resolved raw value from indexes:
            raw = None
            iid = str(cv.get("itemId") or cv.get("fieldId") or "")
            if iid and iid in by_id:
                raw = by_id[iid]
            else:
                k = _norm(item_label)
                raw = by_lbl.get(k, "")
            data.append([
                Paragraph(f"<b>{item_label}</b>", styles["BodySmall"]),
                Paragraph(str(raw or ""), styles["BodySmall"]),
                ""
            ])
    else:
        for sec in sections:
            s_code = sec.get("code") or ""
            s_label = sec.get("label") or ""
            header_txt = (s_code + " " + s_label).strip()
            if header_txt:
                data.append([Paragraph(f"<b>{header_txt}</b>", styles["SectionHeader"]), "", ""])
                section_rows.append(len(data) - 1)

            for item in (sec.get("items") or []):
                t = item.get("type")
                if t in ("header", "label"):
                    txt = ((item.get("code") or "") + " " + (item.get("label") or "")).strip()
                    data.append([Paragraph(f"<b>{txt}</b>", styles["BodySmall"]), "", ""])
                    section_rows.append(len(data) - 1)
                    continue

                val_str = find_answer_for_item(item, by_id, by_lbl, pdf_map)
                label = ((item.get("code") or "") + " " + (item.get("label") or "")).strip()

                data.append([
                    Paragraph(f"<b>{label}</b>", styles["BodySmall"]),
                    Paragraph(val_str, styles["BodySmall"]),
                    ""
                ])

                iid = str(item.get("id") or "")
                if iid in field_photo_paths:
                    for photo_path in field_photo_paths.get(iid, []):
                        if isinstance(photo_path, str) and photo_path and os.path.exists(photo_path):
                            try:
                                img = Image(photo_path, width=IMG_COL_W, height=IMG_COL_W, kind='bound')
                                data[-1][2] = img
                            except Exception:
                                data[-1][2] = Paragraph("(formfield image failed)", styles["BodySmall"])

    table = Table(data, colWidths=[TEXT_COL_W, TEXT_COL_W, IMG_COL_W])
    tbl_styles = [
        ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
        ("VALIGN", (0, 0), (-1, -1), "TOP"),
        ("PADDING", (0, 0), (-1, -1), 6),
        ("FONTNAME", (0, 0), (-1, -1), "Helvetica"),
        ("FONTSIZE", (0, 0), (-1, -1), 10),
        ("VALIGN", (2, 0), (2, -1), "MIDDLE"),
        ("ALIGN",  (2, 0), (2, -1), "CENTER"),
    ]
    for r in section_rows:
        tbl_styles.append(("SPAN", (0, r), (-1, r)))
    table.setStyle(TableStyle(tbl_styles))
    story.append(table)
    story.append(Spacer(1, 12))

    # Referenced Photos Grid (3 across, square cells, bound like field photos)
    story.append(Paragraph("Referenced Photos", styles["SectionHeader"]))
    if ref_photo_paths:
        cols = 3
        cell_w = (A4[0] - (36 + 36) - (cols - 1) * 6) / cols
        rows, row = [], []
        for i, p in enumerate(ref_photo_paths, 1):
            try:
                row.append(Image(p, width=cell_w, height=cell_w, kind='bound'))
            except Exception:
                row.append(Paragraph("(referenced image failed)", styles["BodySmall"]))
            if i % cols == 0:
                rows.append(row); row = []
        if row:
            while len(row) < cols:
                row.append("")
            rows.append(row)
        grid = Table(rows, colWidths=[cell_w] * cols, hAlign="LEFT")
        grid.setStyle(TableStyle([
            ("GRID", (0, 0), (-1, -1), 0.25, colors.lightgrey),
            ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
            ("ALIGN", (0, 0), (-1, -1), "CENTER"),
            ("PADDING", (0, 0), (-1, -1), 4),
        ]))
        story.append(grid)
    else:
        story.append(Paragraph("<i>No referenced photos for this form.</i>", styles["BodySmall"]))

    if page_decorator:
        doc.build(story, onFirstPage=page_decorator, onLaterPages=page_decorator)
    else:
        doc.build(story)

# -----------------------------
# ------------ MAIN -----------
# -----------------------------
def list_forms_for_all_projects(tok: str) -> List[dict]:
    """Utility to list all (project, forms) pairs after template+formDate filtering."""
    addr_map = get_project_addresses(tok)
    results = []
    projects = get_projects(tok)
    if not projects:
        print("No projects found.")
        return results

    for p in projects:
        raw_id = p.get("id") or ""
        project_id = raw_id.replace("b.", "") if raw_id.startswith("b.") else raw_id
        project_name = (p.get("attributes") or {}).get("name") or project_id
        project_address = addr_map.get(project_id, "No address available")
        forms = list_forms_for_template(tok, project_id, FORM_TEMPLATE_NAME)
        if not forms:
            continue
        results.append((project_id, project_name, project_address, forms))
    return results

def main():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    tok = get_access_token()

    logo_path = choose_logo_path_from_config()
    page_logo_draw = make_page_logo_drawer(logo_path) if logo_path else None
    if logo_path:
        print(f"Using logo: {logo_path}")

    produced_pdfs = []
    photo_paths_to_clean = set()

    # Gather forms across all projects (after template + formDate filtering)
    proj_forms = list_forms_for_all_projects(tok)

    # Pre-fetch relationships once per project (for all forms in that project)
    for project_id, project_name, project_address, forms in proj_forms:
        form_field_photos = rel_formfield_to_photos(tok, project_id)
        templates = get_form_templates(tok, project_id)

        for form in forms:
            form_id = form.get("id")
            if not form_id:
                continue

            # Ensure we have answers; detail only if list lacks them
            form = ensure_form_has_answers(tok, project_id, form)

            # referenced photos
            ref_photo_ids = rel_form_to_photos(tok, project_id, form_id)
            ref_photo_meta = photos_filter_by_ids(tok, project_id, ref_photo_ids) if ref_photo_ids else []
            ref_photo_map = download_photos(ref_photo_meta, OUTPUT_DIR, f"ref_{form_id}")
            ref_photo_paths = [ref_photo_map[pid] for pid in ref_photo_ids if pid in ref_photo_map]
            photo_paths_to_clean.update(ref_photo_paths)

            # formfield photos
            field_photos = form_field_photos.get(form_id, {})
            field_photo_ids = []
            for photos in field_photos.values():
                field_photo_ids.extend(photos)
            field_photo_ids = list(dict.fromkeys(field_photo_ids))  # dedupe
            field_photo_meta = photos_filter_by_ids(tok, project_id, field_photo_ids) if field_photo_ids else []
            field_photo_map = download_photos(field_photo_meta, OUTPUT_DIR, f"field_{form_id}")
            photo_paths_to_clean.update(field_photo_map.values())
            field_photo_paths = {field_id: [field_photo_map.get(pid) for pid in photos if pid in field_photo_map]
                                 for field_id, photos in field_photos.items()}

            # template for structure
            tmpl_id = (form.get("formTemplate") or {}).get("id")
            tmpl = template_by_id(templates, tmpl_id) if tmpl_id else None

            safe_proj = "".join(c if c.isalnum() or c in (" ", "-", "_") else "_" for c in project_name).strip()
            out_pdf = os.path.join(OUTPUT_DIR, f"{safe_proj}_{form_id}.pdf")

            render_form_pdf(
                project_name=project_name,
                project_address=project_address,
                form=form,
                template=tmpl or {},
                field_photo_paths=field_photo_paths,
                ref_photo_paths=ref_photo_paths,
                out_path=out_pdf,
                page_decorator=page_logo_draw,  # draw logo on every page
            )
            produced_pdfs.append(out_pdf)
            print(f"Generated PDF for form {form_id}")

    if produced_pdfs:
        merger = PdfMerger()
        for pdf in produced_pdfs:
            try:
                merger.append(pdf)
            except Exception as e:
                print(f"Failed to merge PDF {pdf}: {str(e)}")
        combined_path = os.path.join(OUTPUT_DIR, COMBINED_PDF_NAME)
        merger.write(combined_path)
        merger.close()
        print(f"Combined PDF saved: {combined_path}")
    else:
        print("No form PDFs produced.")

    # cleanup temp photos
    for pth in photo_paths_to_clean:
        try:
            if os.path.exists(pth):
                os.remove(pth)
                print(f"Cleaned up temporary file: {pth}")
        except Exception as e:
            print(f"Failed to clean up {pth}: {str(e)}")

if __name__ == "__main__":
    main()
