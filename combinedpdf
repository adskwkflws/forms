#INSTRUCTIONS

#make sure dependancies from README are installed first 
#Config section is the only section you need to fill out before running 
#Make sure Logo_Path points to the absolute logo file path on your computer 
#copy paste the below script into a .py file, name it weekly_reports.py > save it same folder as get_tokens.py is in


import os
import re
import json
import time
import random
import requests
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse
from datetime import date, timedelta

# ReportLab
from reportlab.lib.pagesizes import A4
from reportlab.platypus import (
    BaseDocTemplate, PageTemplate, Frame,
    Paragraph, Spacer, Table, TableStyle, Image, PageBreak
)
from reportlab.platypus.tableofcontents import TableOfContents
from reportlab.platypus.flowables import Flowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.utils import ImageReader

# Pillow for EXIF-aware rotation
from PIL import Image as PILImage
from PIL import ImageOps

# -----------------------------
# -------- CONFIG -------------
# -----------------------------
CLIENT_ID = "A1nztYubWhnUuGqYYwiAh5GpAFKLlb2SwKpJIo4nl2RmDzL7"
CLIENT_SECRET = "O8XG4Kfyz0xEWyMYx2J8h2pgeRkGfrGOVmHpj7GNT1dJnAsYyeAxLht7EGFcNyK6"
HUB_ID = "b.f4e6839c-aadd-436f-8d8a-2ec020663d3c"
ACCOUNT_ID = HUB_ID.replace("b.", "")
REGION = "US"
FORM_TEMPLATE_NAME = "IN-0005A Project Weekly Report"
TOKENS_FILE = "/Users/alexanderjvanhoff/Documents/Starline Weekly Reports/tokens.json""

# Save directly to a folder on your Mac (change if you like)
OUTPUT_DIR = "/Users/alexanderjvanhoff/Documents/Starline Weekly Reports"

# Auto-dated filename template (e.g., "Weekly Report - 2025-09-16.pdf")
COMBINED_PDF_NAME_TEMPLATE = "Weekly Report - {date}.pdf"

FORMDATE_LAST_N_DAYS = 30  # set None to disable

# --- LOGO ---
LOGO_PATH = "/Users/alexanderjvanhoff/Downloads/Starlinelogo.png"
LOGO_MAX_W = 1.2 * inch
LOGO_MAX_H = 0.40 * inch
LOGO_PADDING_RIGHT = 0
LOGO_PADDING_TOP = 0

# --- PDF Layout / Table widths ---
TEXT_COL_W = 2.5 * inch
IMG_COL_W  = 3.0 * inch

# --- Global Rate Limiting ---
REQUESTS_PER_MINUTE = 60
MAX_RETRIES = 3
BACKOFF_INITIAL = 1.0
BACKOFF_MAX = 10.0
JITTER = 0.25
RESPECT_RETRY_AFTER = True

# --- Non-image attachments handling ---
SHOW_NON_IMAGE_PLACEHOLDER = False  # True => show text if field has only non-image attachments

# -----------------------------
# ---- RATE-LIMITED SESSION ---
# -----------------------------
SESSION = requests.Session()
_LAST_REQ_TS = 0.0
_MIN_INTERVAL = 60.0 / max(1, int(REQUESTS_PER_MINUTE or 1))

def rl_request(method: str, url: str, **kwargs) -> requests.Response:
    """Rate-limited request with basic exponential backoff for 429/5xx."""
    global _LAST_REQ_TS
    attempt = 0
    while True:
        now = time.time()
        wait = max(0.0, _LAST_REQ_TS + _MIN_INTERVAL - now)
        if wait > 0:
            time.sleep(wait)
        _LAST_REQ_TS = time.time()
        resp = SESSION.request(method, url, **kwargs)
        retryable = (resp.status_code == 429) or (500 <= resp.status_code < 600)
        if retryable and attempt < MAX_RETRIES:
            attempt += 1
            delay = BACKOFF_INITIAL * (2 ** (attempt - 1))
            if RESPECT_RETRY_AFTER:
                ra = resp.headers.get("Retry-After")
                if ra:
                    try:
                        delay = float(ra)
                    except Exception:
                        pass
            delay = min(BACKOFF_MAX, delay) + random.uniform(0.0, JITTER)
            time.sleep(delay)
            continue
        return resp

# -----------------------------
# -------- AUTH ---------------
# -----------------------------
def get_access_token() -> str:
    """3-legged (user) token refresh; tokens.json must contain refresh_token."""
    if not os.path.exists(TOKENS_FILE):
        raise RuntimeError("tokens.json missing; run your 3-legged OAuth first.")
    with open(TOKENS_FILE, "r") as f:
        rt = json.load(f)["refresh_token"]
    r = rl_request(
        "POST",
        "https://developer.api.autodesk.com/authentication/v2/token",
        data={
            "grant_type": "refresh_token",
            "refresh_token": rt,
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
        },
        timeout=45,
    )
    r.raise_for_status()
    j = r.json()
    with open(TOKENS_FILE, "w") as f:
        json.dump({"refresh_token": j["refresh_token"]}, f)
    return j["access_token"]

def get_app_only_token() -> str:
    """2-legged (app) token for HQ v1 fallback (account:read)."""
    r = rl_request(
        "POST",
        "https://developer.api.autodesk.com/authentication/v2/token",
        data={
            "grant_type": "client_credentials",
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
            "scope": "account:read",
        },
        timeout=45,
    )
    r.raise_for_status()
    return r.json()["access_token"]

def H(tok: str) -> Dict[str, str]:
    return {
        "Authorization": f"Bearer {tok}",
        "Content-Type": "application/json",
        "x-ads-region": REGION,
    }

# -----------------------------
# ---- LOGO & FOOTER -----------
# -----------------------------
def choose_logo_path_from_config() -> Optional[str]:
    p = (LOGO_PATH or "").strip()
    if not p:
        print("No logo set (LOGO_PATH is empty).")
        return None
    p = os.path.abspath(os.path.expanduser(p))
    if os.path.exists(p):
        return p
    print(f"Logo not found at: {p}\nCWD: {os.getcwd()}")
    return None

def make_page_logo_drawer(logo_path: Optional[str]):
    if not logo_path:
        return lambda canvas, doc: None
    try:
        ir = ImageReader(logo_path)
        iw, ih = ir.getSize()
    except Exception as e:
        print(f"Failed to load logo '{logo_path}': {e}")
        return lambda canvas, doc: None

    def _draw(canvas, doc):
        try:
            scale = min(LOGO_MAX_W / iw, LOGO_MAX_H / ih, 1.0)
            w = iw * scale
            h = ih * scale
            page_w, page_h = doc.pagesize
            x = page_w - doc.rightMargin - w - LOGO_PADDING_RIGHT
            y = page_h - doc.topMargin + (doc.topMargin - h) / 2 + LOGO_PADDING_TOP
            canvas.drawImage(ir, x, y, width=w, height=h, mask='auto')
        except Exception as e:
            print(f"Failed to draw logo on page: {e}")
    return _draw

def make_onpage_decorator(logo_path: Optional[str]):
    logo_draw = make_page_logo_drawer(logo_path)
    def _onpage(canvas, doc):
        # draw logo
        if logo_draw:
            logo_draw(canvas, doc)
        # draw footer page number starting at 1 on the first body page
        body_start = getattr(doc, "body_start_page", None)
        if body_start and canvas.getPageNumber() >= body_start:
            display = canvas.getPageNumber() - body_start + 1
            canvas.saveState()
            canvas.setFont("Helvetica", 9)
            canvas.setFillColor(colors.black)
            page_w, _ = doc.pagesize
            canvas.drawCentredString(page_w / 2.0, 0.5 * inch, str(display))
            canvas.restoreState()
    return _onpage

# -----------------------------
# ---- PROJECT ADDRESSES ------
# -----------------------------
def get_project_addresses(tok: str) -> Dict[str, str]:
    headers = {"Authorization": f"Bearer {tok}", "Content-Type": "application/json"}
    fields = "name,addressLine1,addressLine2,city,stateOrProvince,postalCode,country"
    base_url = f"https://developer.api.autodesk.com/construction/admin/v1/accounts/{ACCOUNT_ID}/projects"
    out = {}
    url = base_url
    params = {"fields": fields}
    while url:
        r = rl_request("GET", url, headers=headers, params=params, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch project addresses: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for p in j.get("results", []):
            pid = p.get("id")
            parts = [
                p.get("addressLine1", ""),
                p.get("addressLine2", ""),
                p.get("city", ""),
                p.get("stateOrProvince", ""),
                p.get("postalCode", ""),
                p.get("country", ""),
            ]
            addr = ", ".join(x for x in parts if x and x != "N/A").strip()
            out[pid] = addr if addr else "No address available"
        url = (j.get("pagination") or {}).get("nextUrl")
        params = {}
    return out

# -----------------------------
# ------ RELATIONSHIPS --------
# -----------------------------
def rel_form_to_photos(tok: str, project_id: str, form_id: str) -> List[str]:
    base = (
        "https://developer.api.autodesk.com/bim360/relationship/v2"
        f"/containers/{project_id}/relationships:search"
        f"?domain=autodesk-construction-form&type=form&id={form_id}"
        "&withDomain=autodesk-construction-photo&withType=photo"
        "&includeDeleted=false&pageLimit=100"
    )
    ids: List[str] = []
    seen = set()
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch form->photo relationships for form {form_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for rel in (j.get("relationships") or []):
            for e in rel.get("entities", []):
                if e.get("domain") == "autodesk-construction-photo" and e.get("type") == "photo":
                    pid = e.get("id")
                    if pid and pid not in seen:
                        ids.append(pid); seen.add(pid)
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return ids

def rel_formfield_to_photos(tok: str, project_id: str) -> Dict[str, Dict[str, List[str]]]:
    """form_id -> field_id -> [photo_id]"""
    base = (
        f"https://developer.api.autodesk.com/bim360/relationship/v2/containers/{project_id}/relationships:search"
        "?domain=autodesk-construction-form&type=formfield"
        "&withDomain=autodesk-construction-photo&withType=photo"
        "&includeDeleted=false&pageLimit=100"
    )
    out: Dict[str, Dict[str, List[str]]] = {}
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch formfield->photo relationships: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for rel in (j.get("relationships") or []):
            entities = rel.get("entities", [])
            ff, pid = None, None
            for e in entities:
                if e.get("domain") == "autodesk-construction-form" and e.get("type") == "formfield":
                    ff = e.get("id")
                if e.get("domain") == "autodesk-construction-photo" and e.get("type") == "photo":
                    pid = e.get("id")
            if ff and pid:
                try:
                    form_id, field_id = ff.replace("urn:adsk:form.field:", "").split("/")
                    out.setdefault(form_id, {}).setdefault(field_id, [])
                    if pid not in out[form_id][field_id]:
                        out[form_id][field_id].append(pid)
                except ValueError:
                    pass
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return out

def rel_formfield_to_attachments(tok: str, project_id: str) -> Dict[str, Dict[str, List[str]]]:
    """form_id -> field_id -> [attachment_id]"""
    base = (
        f"https://developer.api.autodesk.com/bim360/relationship/v2/containers/{project_id}/relationships:search"
        "?domain=autodesk-construction-form&type=formfield"
        "&withDomain=autodesk-construction-attachment&withType=attachment"
        "&includeDeleted=false&pageLimit=100"
    )
    out: Dict[str, Dict[str, List[str]]] = {}
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch formfield->attachment relationships: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for rel in (j.get("relationships") or []):
            entities = rel.get("entities", [])
            ff, aid = None, None
            for e in entities:
                if e.get("domain") == "autodesk-construction-form" and e.get("type") == "formfield":
                    ff = e.get("id")
                if e.get("domain") == "autodesk-construction-attachment" and e.get("type") == "attachment":
                    aid = e.get("id")
            if ff and aid:
                try:
                    form_id, field_id = ff.replace("urn:adsk:form.field:", "").split("/")
                    out.setdefault(form_id, {}).setdefault(field_id, [])
                    if aid not in out[form_id][field_id]:
                        out[form_id][field_id].append(aid)
                except ValueError:
                    pass
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return out

# -----------------------------
# ----- MEDIA FETCH & SAVE ----
# -----------------------------
def photos_filter_by_ids(tok: str, project_id: str, ids: List[str]) -> List[dict]:
    if not ids: return []
    url = f"https://developer.api.autodesk.com/construction/photos/v1/projects/{project_id}/photos:filter"
    out = []
    for i in range(0, len(ids), 50):
        body = {"filter": {"id": ids[i:i+50]}, "include": ["signedUrls"], "limit": 50}
        r = rl_request("POST", url, headers=H(tok), json=body, timeout=60)
        if r.status_code != 200:
            print(f"Failed to fetch photos: {r.status_code} - {r.text}"); continue
        out.extend((r.json() or {}).get("results", []) or [])
    return out

def attachments_filter_by_ids(tok: str, project_id: str, ids: List[str]) -> List[dict]:
    if not ids: return []
    url = f"https://developer.api.autodesk.com/construction/attachments/v2/projects/{project_id}/attachments:filter"
    out = []
    for i in range(0, len(ids), 50):
        body = {"filter": {"id": ids[i:i+50]}, "include": ["signedUrls"], "limit": 50}
        r = rl_request("POST", url, headers=H(tok), json=body, timeout=60)
        if r.status_code != 200:
            print(f"Failed to fetch attachments: {r.status_code} - {r.text}"); continue
        out.extend((r.json() or {}).get("results", []) or [])
    return out

def pick_best_url(signed: dict) -> Optional[str]:
    for k in ("original", "full", "large", "fileUrl", "url", "medium", "thumbnail"):
        v = (signed or {}).get(k)
        if isinstance(v, str) and v.startswith("http"):
            return v
    for v in (signed or {}).values():
        if isinstance(v, str) and v.startswith("http"):
            return v
    return None

def _guess_ext_from_url(u: str) -> str:
    try:
        path = urlparse(u).path
        _, ext = os.path.splitext(path)
        return ext.lower() if ext else ""
    except Exception:
        return ""

def _ext_from_content_type(ct: str) -> str:
    ct = (ct or "").lower()
    if ct.startswith("image/jpeg") or ct.startswith("image/jpg"): return ".jpg"
    if ct.startswith("image/png"): return ".png"
    if ct.startswith("image/gif"): return ".gif"
    if ct.startswith("image/webp"): return ".webp"
    if ct.startswith("image/bmp"): return ".bmp"
    if ct.startswith("image/tiff"): return ".tif"
    return ""

def _normalize_image_orientation(path: str) -> None:
    """Open file with Pillow, apply EXIF transpose, drop EXIF, and overwrite."""
    try:
        with PILImage.open(path) as im:
            im = ImageOps.exif_transpose(im)
            if im.mode in ("P", "RGBA", "LA", "CMYK"):
                im = im.convert("RGB")
            im.save(path)
    except Exception as e:
        print(f"Orientation normalize failed for {path}: {e}")

def download_media_by_meta(metas: List[dict], out_dir: str, prefix: str, require_image: bool) -> Dict[str, str]:
    """
    Download items with signedUrls.
      - If require_image=True, keep only responses whose Content-Type starts with image/.
      - For any image/* payload, normalize EXIF orientation.
    Returns {id: local_path}
    """
    os.makedirs(out_dir, exist_ok=True)
    id2path = {}
    for m in metas or []:
        mid = m.get("id")
        url = pick_best_url(m.get("signedUrls") or {})
        if not (mid and url):
            continue
        try:
            rr = rl_request("GET", url, timeout=90)
            if rr.status_code != 200:
                print(f"Failed to download {prefix} {mid}: HTTP {rr.status_code}")
                continue
            ct = rr.headers.get("Content-Type", "").lower()
            if require_image and not ct.startswith("image/"):
                continue
            ext = _ext_from_content_type(ct) or _guess_ext_from_url(url) or ".bin"
            local = os.path.join(out_dir, f"{prefix}_{mid}{ext}")
            with open(local, "wb") as f:
                f.write(rr.content)
            if ct.startswith("image/"):
                _normalize_image_orientation(local)
            id2path[mid] = local
        except Exception as e:
            print(f"Failed to download {prefix} {mid}: {str(e)}")
    return id2path

# -----------------------------
# ---- ANSWER / NOTES MAPS ----
# -----------------------------
def _norm_key(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").strip().lower())

def build_value_indexes(custom_values: List[dict]) -> Tuple[Dict[str, object], Dict[str, object]]:
    by_id: Dict[str, object] = {}
    by_lbl: Dict[str, object] = {}
    for cv in custom_values or []:
        raw = None
        if "textVal" in cv and cv["textVal"] is not None:
            raw = cv["textVal"]
        elif "multilineTextVal" in cv and cv["multilineTextVal"] is not None:
            raw = cv["multilineTextVal"]
        elif "numberVal" in cv and cv["numberVal"] is not None:
            raw = str(cv["numberVal"])
        elif "dateVal" in cv and cv["dateVal"] is not None:
            raw = cv["dateVal"]
        elif "toggleVal" in cv and cv["toggleVal"] is not None:
            raw = "Yes" if cv["toggleVal"] else "No"
        elif "choiceVal" in cv and cv["choiceVal"] is not None:
            raw = cv["choiceVal"]
        elif "multiChoiceVal" in cv and cv["multiChoiceVal"] is not None:
            raw = cv["multiChoiceVal"]
        elif "value" in cv and cv["value"] is not None:
            raw = cv["value"]

        iid = cv.get("itemId") or cv.get("fieldId")
        if iid is not None:
            by_id[str(iid)] = raw

        lbl = cv.get("itemLabel"); code = cv.get("itemCode")
        if lbl:  by_lbl[_norm_key(lbl)] = raw
        if code: by_lbl[_norm_key(code)] = raw
        if lbl and code:
            by_lbl[_norm_key(f"{code} {lbl}")] = raw
            by_lbl[_norm_key(f"{code}{lbl}")] = raw
    return by_id, by_lbl

def build_pdfvalue_map(form: dict) -> Dict[str, str]:
    out: Dict[str, str] = {}
    for pv in (form.get("pdfValues") or []):
        nm = pv.get("name"); val = pv.get("value")
        if nm:
            out[_norm_key(nm)] = "" if val is None else str(val)
    return out

def build_field_notes_index(custom_values: List[dict]) -> Dict[str, str]:
    """Map itemId/fieldId -> note text (if present on the same question)."""
    idx: Dict[str, str] = {}
    for cv in custom_values or []:
        iid = cv.get("itemId") or cv.get("fieldId")
        if not iid:
            continue
        note = None
        for k in ("notes", "note", "noteVal"):
            v = cv.get(k)
            if isinstance(v, str) and v.strip():
                note = v.strip()
                break
        if note:
            idx[str(iid)] = note
    return idx

def value_to_label(item: dict, value) -> str:
    if value is None:
        return ""
    t = item.get("type", "")
    if t == "choice":
        opts = item.get("options", []) or []
        sel = next((o for o in opts if o.get("id") == value), None)
        return (sel or {}).get("label") or "N/A"
    if t == "multi_choice":
        opts = item.get("options", []) or []
        labels = [o.get("label") for o in opts if o.get("id") in (value or [])]
        return ", ".join([x for x in labels if x]) if labels else "N/A"
    return str(value)

def find_answer_for_item(item: dict, by_id: Dict[str, object], by_lbl: Dict[str, object], pdf_map: Dict[str, str]) -> str:
    item_id = str(item.get("id") or "")
    if item_id and item_id in by_id:
        return value_to_label(item, by_id[item_id])

    code = (item.get("code") or "").strip()
    label = (item.get("label") or "").strip()
    for cand in (code, label, (code + " " + label).strip(), (code + label).strip()):
        k = _norm_key(cand)
        if k and k in by_lbl:
            return value_to_label(item, by_lbl[k])

    for cand in (code, label, (code + " " + label).strip(), (code + label).strip()):
        k = _norm_key(cand)
        if k and k in pdf_map and pdf_map[k]:
            return pdf_map[k]
    return ""

# -----------------------------
# ---- SUBMITTER RESOLUTION ---
# -----------------------------
def get_account_user_index(tok_user: str) -> Dict[str, Dict[str, str]]:
    """
    Build a dictionary of identifiers -> {name,email}.
    Tries Admin v1 first (subjectId). If 404, falls back to HQ v1 (uid) using 2-legged token.
    """
    idx: Dict[str, Dict[str, str]] = {}

    def _remember(ids, name, email):
        for k in ids:
            if not k:
                continue
            idx[str(k)] = {"name": name, "email": email}

    # 1) Admin v1 (subjectId) — 3-legged token
    url = f"https://developer.api.autodesk.com/construction/admin/v1/accounts/{ACCOUNT_ID}/users?limit=100"
    next_url = url
    used_admin = False
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok_user), timeout=45)
        if r.status_code == 404:
            next_url = None
            break
        if r.status_code != 200:
            print(f"Failed to fetch account users (admin v1): {r.status_code} - {r.text}")
            next_url = None
            break
        used_admin = True
        j = r.json() or {}
        for u in (j.get("results") or []):
            sid  = u.get("subjectId") or u.get("id")
            name = u.get("name") or u.get("displayName")
            email= u.get("email")
            _remember([sid, email and (email.lower())], name, email)
        next_url = (j.get("pagination") or {}).get("nextUrl")

    if used_admin:
        return idx

    # 2) HQ v1 fallback (uid) — 2-legged token
    try:
        tok_app = get_app_only_token()
    except Exception as e:
        print(f"Could not get app-only token for HQ v1 users: {e}")
        return idx

    headers = {"Authorization": f"Bearer {tok_app}", "Content-Type":"application/json"}
    offset, limit = 0, 100
    while True:
        url = f"https://developer.api.autodesk.com/hq/v1/accounts/{ACCOUNT_ID}/users?limit={limit}&offset={offset}"
        r = rl_request("GET", url, headers=headers, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch account users (hq v1): {r.status_code} - {r.text}")
            break
        arr = r.json() or []
        if not isinstance(arr, list):
            break
        for u in arr:
            uid  = u.get("uid")            # 12-char Autodesk Account ID
            bid  = u.get("id")             # BIM 360 user UUID
            name = u.get("name")
            email= u.get("email")
            _remember([uid, bid, email and (email.lower())], name, email)
        if len(arr) < limit:
            break
        offset += limit

    return idx

def resolve_submitter_name(form_obj: dict, user_idx: Dict[str, Dict[str, str]]) -> str:
    """
    Returns NAME only:
      1) submittedBy resolved via user_idx (subjectId/email/uid) -> name
      2) else submittedBy.name if present
      3) else createdBy resolved via user_idx -> name
      4) else createdBy.name
      5) else 'Unknown user'
    """
    sb = form_obj.get("submittedBy") or {}
    cb = form_obj.get("createdBy") or {}
    if isinstance(sb, str): sb = {"id": sb}
    if isinstance(cb, str): cb = {"id": cb}

    def _name_from_userdict(u: dict) -> Optional[str]:
        if not isinstance(u, dict):
            return None
        keys = [u.get("subjectId"), u.get("id"), (u.get("email") or "").lower(), (u.get("uid") or "")]
        for k in keys:
            if k and k in user_idx and user_idx[k].get("name"):
                return user_idx[k]["name"]
        n = u.get("name") or u.get("displayName")
        return n

    name = _name_from_userdict(sb)
    if name:
        return name
    name = _name_from_userdict(cb)
    if name:
        return name
    return "Unknown user"

# -----------------------------
# --------- STYLES ------------
# -----------------------------
def make_styles():
    styles = getSampleStyleSheet()
    brand = colors.HexColor("#0055A4")
    link_blue = colors.HexColor("#1155CC")

    style_definitions = [
        {'name': 'Title', 'parent': styles.get('Heading1', styles['Normal']),
         'alignment': 1, 'fontSize': 22, 'textColor': brand, 'spaceAfter': 18},

        {'name': 'TOCHeader', 'parent': styles.get('Heading2', styles['Normal']),
         'alignment': 1, 'fontSize': 16, 'textColor': brand, 'spaceAfter': 36},  # more gap

        {'name': 'SectionHeader', 'parent': styles.get('Heading2', styles['Normal']),
         'fontSize': 14, 'textColor': brand, 'spaceAfter': 10, 'leading': 16},

        {'name': 'FormName', 'parent': styles.get('Heading2', styles['Normal']),
         'alignment': 1, 'fontSize': 14, 'textColor': brand, 'spaceAfter': 4, 'leading': 16},

        {'name': 'SubmittedBy', 'parent': styles.get('Normal', styles['Normal']),
         'alignment': 1, 'fontSize': 10, 'leading': 12, 'spaceAfter': 8, 'textColor': brand},

        {'name': 'CenteredAddress', 'parent': styles.get('Normal', styles['Normal']),
         'alignment': 1, 'fontSize': 10, 'leading': 12, 'spaceAfter': 4},

        {'name': 'BodySmall', 'parent': styles.get('Normal', styles['Normal']),
         'fontSize': 10, 'leading': 12, 'spaceAfter': 4},

        # Invisible trigger paragraph we use to register a TOC entry/bookmark for each form
        {'name': 'FormAnchor', 'parent': styles.get('Normal', styles['Normal']),
         'fontSize': 0.1, 'leading': 0.2, 'spaceAfter': 0, 'textColor': colors.white},
    ]  # <-- this closing bracket must be present

    for sd in style_definitions:
        nm = sd['name']
        if nm not in styles.byName and nm not in styles.byAlias:
            styles.add(ParagraphStyle(**sd))

    styles.add(ParagraphStyle(
        name='TOCLevel0',
        fontName='Helvetica',
        fontSize=12,
        leftIndent=24,
        firstLineIndent=-12,
        spaceBefore=8,
        leading=16,
        textColor=link_blue,
    ))
    styles['TOCLevel0'].linkUnderline = 0
    return styles

# -----------------------------
# ---- TOC-AWARE DOCTEMPLATE --
# -----------------------------
class BodyStart(Flowable):
    """Zero-height flowable to mark the first body page."""
    def __init__(self): super().__init__(); self.width = 0; self.height = 0
    def draw(self): pass

class TOCDocTemplate(BaseDocTemplate):
    def __init__(self, filename, **kw):
        super().__init__(filename, **kw)
        frame = Frame(self.leftMargin, self.bottomMargin,
                      self.width, self.height, id='normal')
        template = PageTemplate(id='Pages', frames=[frame], onPage=kw.get('onPage'))
        self.addPageTemplates([template])
        self.page_offset = 0         # number to subtract from actual page to display in TOC
        self.body_start_page = None  # first body page number

    def afterFlowable(self, flowable):
        # Mark first body page (immediately after TOC)
        if isinstance(flowable, BodyStart):
            self.body_start_page = self.page
            self.page_offset = self.page - 1  # so body_start shows as page 1
            return

        # Register each form via the invisible FormAnchor paragraph
        if isinstance(flowable, Paragraph) and flowable.style.name == 'FormAnchor':
            text = flowable.getPlainText()
            key = re.sub(r'[^a-z0-9]+', '-', text.strip().lower()) + f"-p{self.page}"
            self.canv.bookmarkPage(key)
            try:
                self.canv.addOutlineEntry(text, key, level=0, closed=False)
            except Exception:
                pass
            # Adjust the page number shown in the TOC so numbering starts at 1 after TOC
            display_page = self.page - (self.page_offset or 0)
            self.notify('TOCEntry', (0, text, display_page, key))

# -----------------------------
# ---- CUSTOM TOC (partial link)
# -----------------------------

class PartialLinkTOC(Flowable):
    """
    Collects TOCEntry notifications like TableOfContents,
    but draws each entry with ONLY the left label clickable (blue),
    while the dot leaders + page number are black and NOT clickable.
    """
    def __init__(self, levelStyles=None, dotsMinLevel=0,
                 linkColor=colors.HexColor("#1155CC"), dotsColor=colors.black):
        super().__init__()
        self.levelStyles = levelStyles or []
        self.dotsMinLevel = dotsMinLevel
        self.linkColor = linkColor
        self.dotsColor = dotsColor
        self._entries: List[Tuple[int, str, int, str]] = []
        self._lastEntries: Optional[List[Tuple[int, str, int, str]]] = None
        self._satisfied: bool = False
        self.width = 0
        self.height = 0

    # ---- IndexingFlowable API ----
    def isIndexing(self):
        return True

    def beforeBuild(self):
        # reset collection for this pass
        self._entries = []
        self._satisfied = False

    def afterBuild(self):
        # satisfied iff entries are identical to previous pass
        if self._lastEntries is not None and self._lastEntries == self._entries:
            self._satisfied = True
        # store snapshot for next pass comparison
        self._lastEntries = list(self._entries)

    def isSatisfied(self):
        return self._satisfied

    # ---- Notifications from DocTemplate ----
    def notify(self, kind, stuff):
        if kind == 'TOCEntry':
            # stuff = (level, text, pageNum, key)
            self._entries.append(stuff)

    # ---- Helpers ----
    def _current_entries(self):
        # When drawing early in the pass (before body), _entries is still empty.
        # Use previous pass’s snapshot so the TOC is not blank.
        return self._entries if self._entries else (self._lastEntries or [])

    # ---- Layout & drawing ----
    def wrap(self, availWidth, availHeight):
        self.width = availWidth
        entries = self._current_entries()
        if not entries:
            # Pass 1, no data yet: reserve a small placeholder height.
            base = self.levelStyles[0] if self.levelStyles else getSampleStyleSheet()['Normal']
            leading = getattr(base, 'leading', base.fontSize * 1.2)
            self.height = 2 * leading
            return availWidth, self.height

        h = 0
        for level, _, __, ___ in entries:
            style = self.levelStyles[min(level, len(self.levelStyles)-1)] if self.levelStyles else getSampleStyleSheet()['Normal']
            h += getattr(style, 'spaceBefore', 0) + getattr(style, 'leading', style.fontSize * 1.2)
        self.height = h
        return availWidth, h

    def draw(self):
        canv = self.canv
        entries = self._current_entries()
        y = self.height
        for level, text, pageNum, key in entries:
            style = self.levelStyles[min(level, len(self.levelStyles)-1)] if self.levelStyles else getSampleStyleSheet()['Normal']
            leading = getattr(style, 'leading', style.fontSize * 1.2)
            spaceBefore = getattr(style, 'spaceBefore', 0)
            y -= spaceBefore

            # Positions
            label_x = style.leftIndent + (getattr(style, 'firstLineIndent', 0) or 0)
            canv.setFont(style.fontName, style.fontSize)
            label_w = canv.stringWidth(text, style.fontName, style.fontSize)

            page_str = str(pageNum)
            page_w = canv.stringWidth(page_str, style.fontName, style.fontSize)
            page_x = self.width - page_w
            baseline = y - (leading - style.fontSize)

            # Label (blue, clickable)
            canv.saveState()
            canv.setFillColor(self.linkColor)
            canv.drawString(label_x, baseline, text)
            canv.restoreState()

            # Dot leaders (black, non-clickable)
            start_dots = label_x + label_w + 6
            if page_x > start_dots:
                dot_w = canv.stringWidth('.', style.fontName, style.fontSize)
                count = int((page_x - start_dots) / max(dot_w, 0.1))
                if count > 0:
                    canv.saveState()
                    canv.setFillColor(self.dotsColor)
                    canv.drawString(start_dots, baseline, '.' * count)
                    canv.restoreState()

            # Page number (black, non-clickable)
            canv.saveState()
            canv.setFillColor(colors.black)
            canv.drawString(page_x, baseline, page_str)
            canv.restoreState()

            # Clickable region ONLY over the label
            if key:
                rect = (label_x, baseline - 1, label_x + label_w, baseline + style.fontSize + 1)
                canv.linkRect("", key, rect, relative=1, thickness=0, dashArray=None, color=None)

            y -= leading

# -----------------------------
# --------- HELPERS -----------
# -----------------------------
def strip_numeric_prefix(name: str) -> str:
    """Remove leading digits + separators so '001 - King George' sorts by 'King George'."""
    if not name:
        return ""
    return re.sub(r'^\s*\d+\s*[-–_:.)]*\s*', '', name).strip()

def project_display_name(name: str) -> str:
    cleaned = strip_numeric_prefix(name)
    return cleaned or (name or "")

def formnum_as_int(form_obj: dict) -> int:
    v = form_obj.get("formNum")
    try:
        return int(v)
    except Exception:
        return 10**9  # push unknowns to end

def _media_cell(image_path: str, note_text: str, styles) -> Table:
    """Inner one-column table: [Image] then optional [Note] (kept together)."""
    elems = [[Image(image_path, width=IMG_COL_W, height=IMG_COL_W, kind='bound')]]
    if note_text:
        elems.append([Paragraph(note_text, styles["BodySmall"])])
    t = Table(elems, colWidths=[IMG_COL_W])
    t.setStyle(TableStyle([
        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
        ("ALIGN",  (0, 0), (-1, -1), "CENTER"),
        ("LEFTPADDING",  (0, 0), (-1, -1), 0),
        ("RIGHTPADDING", (0, 0), (-1, -1), 0),
        ("TOPPADDING",   (0, 0), (-1, -1), 2),
        ("BOTTOMPADDING",(0, 0), (-1, -1), 2),
    ]))
    return t

# -----------------------------
# ---- FORM FLOWABLES ---------
# -----------------------------
def build_form_flowables(
    project_name: str,
    project_address: str,
    form: dict,
    template: dict,
    field_media_paths: Dict[str, List[str]],
    ref_photo_paths: List[str],
    submitter_name: str,
    styles,
) -> List:
    story = []

    # Add an invisible anchor paragraph to register a TOC entry and bookmark for THIS form
    toc_title = f"{project_display_name(project_name)} — Form #{form.get('formNum', '')}"
    story.append(Paragraph(toc_title, styles["FormAnchor"]))

    # Visible header
    story.append(Paragraph(project_name, styles["Title"]))
    story.append(Paragraph(project_address or "No address available", styles["CenteredAddress"]))
    story.append(Paragraph(f"Form #{form.get('formNum', '')}: {FORM_TEMPLATE_NAME}", styles["FormName"]))
    story.append(Paragraph(f"Submitted by: {submitter_name}", styles["SubmittedBy"]))
    story.append(Spacer(1, 8))

    # Answers / notes
    custom_values = form.get("customValues") or []
    by_id, by_lbl = build_value_indexes(custom_values)
    pdf_map = build_pdfvalue_map(form)
    notes_idx = build_field_notes_index(custom_values)

    data = []
    section_rows: List[int] = []
    sections = (template or {}).get("sections") or []

    if not sections:
        current_section = None
        for cv in custom_values:
            sec_label = cv.get("sectionLabel") or "Section"
            if sec_label != current_section:
                data.append([Paragraph(f"<b>{sec_label}</b>", styles["SectionHeader"]), "", ""])
                section_rows.append(len(data) - 1)
                current_section = sec_label

            item_label = cv.get("itemLabel") or "Item"
            iid = str(cv.get("itemId") or cv.get("fieldId") or "")
            raw = by_id.get(iid, by_lbl.get(_norm_key(item_label), ""))

            data.append([Paragraph(f"<b>{item_label}</b>", styles["BodySmall"]),
                         Paragraph(str(raw or ""), styles["BodySmall"]), ""])

            media_paths = field_media_paths.get(iid, [])
            note_text = notes_idx.get(iid, "")

            if media_paths[:1]:
                try:
                    data[-1][2] = _media_cell(media_paths[0], note_text, styles)
                except Exception:
                    if SHOW_NON_IMAGE_PLACEHOLDER:
                        data[-1][2] = Paragraph("(non-image attachment)", styles["BodySmall"])

            for extra in media_paths[1:]:
                try:
                    data.append(["", "", _media_cell(extra, note_text, styles)])
                except Exception:
                    if SHOW_NON_IMAGE_PLACEHOLDER:
                        data.append(["", "", Paragraph("(non-image attachment)", styles["BodySmall"])])
    else:
        for sec in sections:
            s_code = sec.get("code") or ""
            s_label = sec.get("label") or ""
            header_txt = (s_code + " " + s_label).strip()
            if header_txt:
                data.append([Paragraph(f"<b>{header_txt}</b>", styles["SectionHeader"]), "", ""])
                section_rows.append(len(data) - 1)

            for item in (sec.get("items") or []):
                t = item.get("type")
                if t in ("header", "label"):
                    txt = ((item.get("code") or "") + " " + (item.get("label") or "")).strip()
                    data.append([Paragraph(f"<b>{txt}</b>", styles["BodySmall"]), "", ""])
                    section_rows.append(len(data) - 1)
                    continue

                val_str = find_answer_for_item(item, by_id, by_lbl, pdf_map)
                label = ((item.get("code") or "") + " " + (item.get("label") or "")).strip()

                data.append([Paragraph(f"<b>{label}</b>", styles["BodySmall"]),
                             Paragraph(val_str, styles["BodySmall"]), ""])

                iid = str(item.get("id") or "")
                media_paths = field_media_paths.get(iid, [])
                note_text = notes_idx.get(iid, "")

                if media_paths[:1]:
                    try:
                        data[-1][2] = _media_cell(media_paths[0], note_text, styles)
                    except Exception:
                        if SHOW_NON_IMAGE_PLACEHOLDER:
                            data[-1][2] = Paragraph("(non-image attachment)", styles["BodySmall"])

                for extra in media_paths[1:]:
                    try:
                        data.append(["", "", _media_cell(extra, note_text, styles)])
                    except Exception:
                        if SHOW_NON_IMAGE_PLACEHOLDER:
                            data.append(["", "", Paragraph("(non-image attachment)", styles["BodySmall"])])

    table = Table(data, colWidths=[TEXT_COL_W, TEXT_COL_W, IMG_COL_W])
    tbl_styles = [
        ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
        ("VALIGN", (0, 0), (-1, -1), "TOP"),
        ("PADDING", (0, 0), (-1, -1), 6),
        ("FONTNAME", (0, 0), (-1, -1), "Helvetica"),
        ("FONTSIZE", (0, 0), (-1, -1), 10),
        ("VALIGN", (2, 0), (2, -1), "MIDDLE"),
        ("ALIGN",  (2, 0), (2, -1), "CENTER"),
    ]
    for r in section_rows:
        tbl_styles.append(("SPAN", (0, r), (-1, r)))
    table.setStyle(TableStyle(tbl_styles))
    story.append(table)
    story.append(Spacer(1, 12))

    # Referenced Photos grid (3 across)
    story.append(Paragraph("Referenced Photos", styles["SectionHeader"]))
    if ref_photo_paths:
        cols = 3
        cell_w = (A4[0] - (36 + 36) - (cols - 1) * 6) / cols
        rows, row = [], []
        for i, p in enumerate(ref_photo_paths, 1):
            try:
                row.append(Image(p, width=cell_w, height=cell_w, kind='bound'))
            except Exception:
                row.append(Paragraph("(referenced image failed)", styles["BodySmall"]))
            if i % cols == 0:
                rows.append(row); row = []
        if row:
            while len(row) < cols:
                row.append("")
            rows.append(row)
        grid = Table(rows, colWidths=[cell_w] * cols, hAlign="LEFT")
        grid.setStyle(TableStyle([
            ("GRID", (0, 0), (-1, -1), 0.25, colors.lightgrey),
            ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
            ("ALIGN", (0, 0), (-1, -1), "CENTER"),
            ("PADDING", (0, 0), (-1, -1), 4),
        ]))
        story.append(grid)
    else:
        story.append(Paragraph("<i>No referenced photos for this form.</i>", styles["BodySmall"]))

    return story

# -----------------------------
# --------- FORMS -------------
# -----------------------------
def get_projects(tok: str) -> List[dict]:
    url = f"https://developer.api.autodesk.com/project/v1/hubs/{HUB_ID}/projects"
    projects: List[dict] = []
    next_url = url
    while next_url:
        r = rl_request("GET", next_url, headers={"Authorization": f"Bearer {tok}"}, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch projects: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        projects.extend(j.get("data", []) or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return projects

def _filter_by_formdate(forms: List[dict]) -> List[dict]:
    if not FORMDATE_LAST_N_DAYS or FORMDATE_LAST_N_DAYS <= 0:
        return forms
    cutoff = date.today() - timedelta(days=FORMDATE_LAST_N_DAYS)
    out = []
    for f in forms:
        fd = f.get("formDate")
        try:
            d = date.fromisoformat(fd) if fd else None
        except Exception:
            d = None
        if d and d >= cutoff:
            out.append(f)
    return out

def list_forms_for_template(tok: str, project_id: str, template_name: str) -> List[dict]:
    forms: List[dict] = []
    next_url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/forms"
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch forms for project {project_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        forms.extend(j.get("data") or j.get("results") or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")

    matching = [f for f in forms if (f.get("formTemplate") or {}).get("name") == template_name]
    matching = _filter_by_formdate(matching)
    return matching

def get_form_templates(tok: str, project_id: str) -> List[dict]:
    url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/form-templates?limit=50"
    out = []
    next_url = url
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if not (200 <= r.status_code < 300):
            print(f"Failed to fetch templates for project {project_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        out.extend(j.get("data") or j.get("results") or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return out

def template_by_id(templates: List[dict], template_id: str) -> Optional[dict]:
    for t in templates:
        if t.get("id") == template_id:
            return t
    return None

# -----------------------------
# ------------ MAIN -----------
# -----------------------------
def list_forms_for_all_projects(tok: str) -> List[Tuple[str, str, str, List[dict]]]:
    addr_map = get_project_addresses(tok)
    results = []
    projects = get_projects(tok)
    if not projects:
        print("No projects found.")
        return results

    for p in projects:
        raw_id = p.get("id") or ""
        project_id = raw_id.replace("b.", "") if raw_id.startswith("b.") else raw_id
        project_name = (p.get("attributes") or {}).get("name") or project_id
        project_address = addr_map.get(project_id, "No address available")
        forms = list_forms_for_template(tok, project_id, FORM_TEMPLATE_NAME)
        if not forms:
            continue
        results.append((project_id, project_name, project_address, forms))
    return results

def main():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    tok = get_access_token()

    # Build a user index once (subjectId/uid/email -> name/email)
    user_index = get_account_user_index(tok)

    logo_path = choose_logo_path_from_config()
    onpage_draw = make_onpage_decorator(logo_path)
    if logo_path:
        print(f"Using logo: {logo_path}")

    # Gather all projects/forms, then sort projects by cleaned display name
    proj_forms = list_forms_for_all_projects(tok)
    proj_forms.sort(key=lambda tup: project_display_name(tup[1]).lower())

    # Build dated filename (avoid overwrite by adding (2), (3), ... if needed)
    run_date = date.today().strftime("%m-%d-%y")
    combined_name = COMBINED_PDF_NAME_TEMPLATE.format(date=run_date)
    base, ext = os.path.splitext(combined_name)
    candidate = combined_name
    i = 2
    while os.path.exists(os.path.join(OUTPUT_DIR, candidate)):
        candidate = f"{base} ({i}){ext}"
        i += 1
    combined_path = os.path.join(OUTPUT_DIR, candidate)

    # Prepare single combined PDF with a real TOC on page 1
    doc = TOCDocTemplate(
        combined_path,
        pagesize=A4,
        onPage=onpage_draw,
        leftMargin=36, rightMargin=36, topMargin=36, bottomMargin=36
    )
    styles = make_styles()
    story: List = []

    # --- TOC front page (page 1) ---
    # --- TOC front page (page 1) ---
    story.append(Paragraph("Weekly Project Report", styles["Title"]))
    story.append(Paragraph("Table of Contents", styles["TOCHeader"]))
    story.append(Spacer(1, 36))  # gap under the heading (36pt ≈ 0.5")
    
    toc = PartialLinkTOC(
        levelStyles=[styles['TOCLevel0']],
        dotsMinLevel=0,
        linkColor=styles['TOCLevel0'].textColor,
        dotsColor=colors.black,
    )
    story.append(toc)
    
    story.append(Spacer(1, 18))  # space below the TOC
    story.append(PageBreak())

    # Marker to detect first body page (so TOC numbering starts at 1)
    story.append(BodyStart())

    temp_paths_to_clean = set()

    # Build body: each form starts on a new page and TOC entries are registered
    first_form = True
    for project_id, project_name, project_address, forms in proj_forms:
        # Sort forms by Form # within the project
        forms_sorted = sorted(forms, key=formnum_as_int)

        # Pre-fetch relationships/templates once per project
        field_photos_all = rel_formfield_to_photos(tok, project_id)       # form_id -> field_id -> [photoId]
        field_atts_all   = rel_formfield_to_attachments(tok, project_id)  # form_id -> field_id -> [attachId]
        templates = get_form_templates(tok, project_id)

        for form in forms_sorted:
            form_id = form.get("id")
            if not form_id:
                continue

            # Ensure each form starts on its own page
            if not first_form:
                story.append(PageBreak())
            first_form = False

            # Referenced photos (bottom grid)
            ref_photo_ids  = rel_form_to_photos(tok, project_id, form_id)
            ref_photo_meta = photos_filter_by_ids(tok, project_id, ref_photo_ids) if ref_photo_ids else []
            ref_photo_map  = download_media_by_meta(ref_photo_meta, OUTPUT_DIR, f"ref_{form_id}", require_image=False)
            ref_photo_paths = [ref_photo_map[pid] for pid in ref_photo_ids if pid in ref_photo_map]
            temp_paths_to_clean.update(ref_photo_paths)

            # Field-level photos
            field_photos = field_photos_all.get(form_id, {})
            fp_ids_all = []
            for ids in (field_photos or {}).values():
                fp_ids_all.extend(ids)
            fp_ids_all = list(dict.fromkeys(fp_ids_all))
            fp_meta = photos_filter_by_ids(tok, project_id, fp_ids_all) if fp_ids_all else []
            fp_map  = download_media_by_meta(fp_meta, OUTPUT_DIR, f"fieldphoto_{form_id}", require_image=False)
            temp_paths_to_clean.update(fp_map.values())

            # Field-level attachments (images only)
            field_atts = field_atts_all.get(form_id, {})
            fa_ids_all = []
            for ids in (field_atts or {}).values():
                fa_ids_all.extend(ids)
            fa_ids_all = list(dict.fromkeys(fa_ids_all))
            fa_meta = attachments_filter_by_ids(tok, project_id, fa_ids_all) if fa_ids_all else []
            fa_map  = download_media_by_meta(fa_meta, OUTPUT_DIR, f"fieldatt_{form_id}", require_image=True)
            temp_paths_to_clean.update(fa_map.values())

            # Merge media paths per field
            field_media_paths: Dict[str, List[str]] = {}
            for field_id, ids in (field_photos or {}).items():
                paths = [fp_map[i] for i in ids if i in fp_map]
                if paths:
                    field_media_paths.setdefault(field_id, []).extend(paths)
            for field_id, ids in (field_atts or {}).items():
                paths = [fa_map[i] for i in ids if i in fa_map]
                if paths:
                    field_media_paths.setdefault(field_id, []).extend(paths)

            # Template structure
            tmpl_id = (form.get("formTemplate") or {}).get("id")
            tmpl = template_by_id(templates, tmpl_id) if tmpl_id else None

            # Submitter name
            submitter_name = resolve_submitter_name(form, user_index)

            # Add the form contents
            story.extend(
                build_form_flowables(
                    project_name=project_name,
                    project_address=project_address,
                    form=form,
                    template=tmpl or {},
                    field_media_paths=field_media_paths,
                    ref_photo_paths=ref_photo_paths,
                    submitter_name=submitter_name,
                    styles=styles,
                )
            )

    # Build (TOC is auto-populated by afterFlowable hooks)
    doc.multiBuild(story)
    print(f"Combined PDF saved: {combined_path}")

    # Cleanup temp files
    for pth in temp_paths_to_clean:
        try:
            if os.path.exists(pth):
                os.remove(pth)
                print(f"Cleaned: {pth}")
        except Exception as e:
            print(f"Failed to clean up {pth}: {str(e)}")

if __name__ == "__main__":
    main()
