#INSTRUCTIONS

#You only need to enter details under CONFIG heading, everything else should work as is 

import os
import json
import time
import random
import requests
from typing import Dict, List, Optional
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.utils import ImageReader
from PyPDF2 import PdfMerger
from datetime import date, timedelta

# -----------------------------
# -------- CONFIG -------------
# -----------------------------
CLIENT_ID = "INSERT HERE" #copy paste from your APS app 
CLIENT_SECRET = "INSERT HERE" #copy paste from your APS app 
HUB_ID = "b.INSERT ACCOUNT ID HERE" #copy paste your account ID here with a "b." prefix
ACCOUNT_ID = HUB_ID.replace("b.", "")
REGION = "US"
FORM_TEMPLATE_NAME = "IN-0005A Project Weekly Report" #must be exact in order to work 
TOKENS_FILE = "tokens.json"
OUTPUT_DIR = "form_pdfs" #folder to route PDF to 
COMBINED_PDF_NAME = "testcombined.pdf" #final PDF file name 
FORMDATE_LAST_N_DAYS = None  #filter by formdate

# --- LOGO ---
LOGO_PATH = "/Users/alexanderjvanhoff/Downloads/Starlinelogo.png" #copy paste the file path to your logo image 
LOGO_MAX_W = 1.2 * inch      
LOGO_MAX_H = 0.40 * inch    
LOGO_PADDING_RIGHT = 0      
LOGO_PADDING_TOP = 0        

# --- PDF Layout / Table widths ---
TEXT_COL_W = 2.5 * inch
IMG_COL_W  = 3.0 * inch 

# --- Global Rate Limiting ---
REQUESTS_PER_MINUTE = 60   
MAX_RETRIES = 3           
BACKOFF_INITIAL = 1.0      
BACKOFF_MAX = 10.0        
JITTER = 0.25              
RESPECT_RETRY_AFTER = True 

# -----------------------------
# ---- RATE-LIMITED SESSION ---
# -----------------------------
SESSION = requests.Session()
_LAST_REQ_TS = 0.0
_MIN_INTERVAL = 60.0 / max(1, int(REQUESTS_PER_MINUTE or 1))

def rl_request(method: str, url: str, **kwargs) -> requests.Response:
    """
    Rate-limited request with basic exponential backoff for 429/5xx.
    Returns the response (even on non-2xx), caller decides how to handle.
    """
    global _LAST_REQ_TS
    attempt = 0
    while True:
        # pacing
        now = time.time()
        wait = max(0.0, _LAST_REQ_TS + _MIN_INTERVAL - now)
        if wait > 0:
            time.sleep(wait)

        _LAST_REQ_TS = time.time()
        resp = SESSION.request(method, url, **kwargs)

        # retry logic for 429/5xx
        retryable = (resp.status_code == 429) or (500 <= resp.status_code < 600)
        if retryable and attempt < MAX_RETRIES:
            attempt += 1
            delay = BACKOFF_INITIAL * (2 ** (attempt - 1))
            if RESPECT_RETRY_AFTER:
                ra = resp.headers.get("Retry-After")
                if ra:
                    try:
                        delay = float(ra)
                    except Exception:
                        pass
            delay = min(BACKOFF_MAX, delay) + random.uniform(0.0, JITTER)
            time.sleep(delay)
            continue
        return resp

# -----------------------------
# -------- AUTH ---------------
# -----------------------------
def get_access_token() -> str:
    if not os.path.exists(TOKENS_FILE):
        raise RuntimeError("tokens.json missing; run your 3-legged OAuth first.")
    with open(TOKENS_FILE, "r") as f:
        rt = json.load(f)["refresh_token"]
    r = rl_request(
        "POST",
        "https://developer.api.autodesk.com/authentication/v2/token",
        data={
            "grant_type": "refresh_token",
            "refresh_token": rt,
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
        },
        timeout=45,
    )
    r.raise_for_status()
    j = r.json()
    with open(TOKENS_FILE, "w") as f:
        json.dump({"refresh_token": j["refresh_token"]}, f)
    return j["access_token"]

def H(tok: str) -> Dict[str, str]:
    return {
        "Authorization": f"Bearer {tok}",
        "Content-Type": "application/json",
        "x-ads-region": REGION,
    }

# -----------------------------
# ---- LOGO DRAWING -----------
# -----------------------------
def choose_logo_path_from_config() -> Optional[str]:
    p = (LOGO_PATH or "").strip()
    if not p:
        print("No logo set (LOGO_PATH is empty).")
        return None
    p = os.path.abspath(os.path.expanduser(p))
    if os.path.exists(p):
        return p
    print(f"Logo not found at: {p}\nCurrent working directory: {os.getcwd()}")
    return None

def make_page_logo_drawer(logo_path: Optional[str]):
    """Return a function(canvas, doc) that draws the logo (if any) on each page."""
    if not logo_path:
        return lambda canvas, doc: None
    try:
        ir = ImageReader(logo_path)
        iw, ih = ir.getSize()
    except Exception as e:
        print(f"Failed to load logo '{logo_path}': {e}")
        return lambda canvas, doc: None

    def _draw(canvas, doc):
        try:
            scale = min(LOGO_MAX_W / iw, LOGO_MAX_H / ih, 1.0)
            w = iw * scale
            h = ih * scale
            page_w, page_h = doc.pagesize
            x = page_w - doc.rightMargin - w - LOGO_PADDING_RIGHT
            y = page_h - doc.topMargin + (doc.topMargin - h) / 2 + LOGO_PADDING_TOP
            canvas.drawImage(ir, x, y, width=w, height=h, mask='auto')
        except Exception as e:
            print(f"Failed to draw logo on page: {e}")
    return _draw

# -----------------------------
# ---- PROJECT ADDRESSES ------
# -----------------------------
def get_project_addresses(tok: str) -> Dict[str, str]:
    headers = {"Authorization": f"Bearer {tok}", "Content-Type": "application/json"}
    fields = "name,addressLine1,addressLine2,city,stateOrProvince,postalCode,country"
    base_url = f"https://developer.api.autodesk.com/construction/admin/v1/accounts/{ACCOUNT_ID}/projects"
    out = {}
    url = base_url
    params = {"fields": fields}
    while url:
        r = rl_request("GET", url, headers=headers, params=params, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch project addresses: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        for p in j.get("results", []):
            pid = p.get("id")
            parts = [
                p.get("addressLine1", ""),
                p.get("addressLine2", ""),
                p.get("city", ""),
                p.get("stateOrProvince", ""),
                p.get("postalCode", ""),
                p.get("country", ""),
            ]
            addr = ", ".join(x for x in parts if x and x != "N/A").strip()
            out[pid] = addr if addr else "No address available"
        url = (j.get("pagination") or {}).get("nextUrl")
        params = {}
    return out

# -----------------------------
# ------ RELATIONSHIPS --------
# -----------------------------
def rel_form_to_photos(tok: str, project_id: str, form_id: str) -> List[str]:
    base = (
        "https://developer.api.autodesk.com/bim360/relationship/v2"
        f"/containers/{project_id}/relationships:search"
        f"?domain=autodesk-construction-form&type=form&id={form_id}"
        "&withDomain=autodesk-construction-photo&withType=photo"
        "&includeDeleted=false&pageLimit=100"
    )
    ids: List[str] = []
    seen = set()
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch form relationships for form {form_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        relationships = (j.get("relationships") or [])
        print(f"Fetched {len(relationships)} referenced photo relationships page for form {form_id}")
        for rel in relationships:
            for e in rel.get("entities", []):
                if e.get("domain") == "autodesk-construction-photo" and e.get("type") == "photo":
                    pid = e.get("id")
                    if pid and pid not in seen:
                        ids.append(pid)
                        seen.add(pid)
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return ids

def rel_formfield_to_photos(tok: str, project_id: str) -> Dict[str, Dict[str, List[str]]]:
    base = (
        f"https://developer.api.autodesk.com/bim360/relationship/v2/containers/{project_id}/relationships:search"
        "?domain=autodesk-construction-form&type=formfield"
        "&withDomain=autodesk-construction-photo&withType=photo"
        "&includeDeleted=false&pageLimit=100"
    )
    form_field_photos: Dict[str, Dict[str, List[str]]] = {}
    next_url = base
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch formfield relationships: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        relationships = (j.get("relationships") or [])
        print(f"Fetched {len(relationships)} formfield relationships page")
        for rel in relationships:
            entities = rel.get("entities", [])
            if (
                len(entities) > 1 and
                entities[1].get("domain") == "autodesk-construction-form" and
                entities[1].get("type") == "formfield" and
                entities[0].get("domain") == "autodesk-construction-photo" and
                entities[0].get("type") == "photo"
            ):
                field_urn = entities[1].get("id")
                photo_id = entities[0].get("id")
                if not (field_urn and photo_id):
                    continue
                try:
                    form_id, field_id = field_urn.replace("urn:adsk:form.field:", "").split("/")
                    form_field_photos.setdefault(form_id, {}).setdefault(field_id, [])
                    if photo_id not in form_field_photos[form_id][field_id]:
                        form_field_photos[form_id][field_id].append(photo_id)
                        print(f"Matched form {form_id} field {field_id} with formfield photo {photo_id}")
                except ValueError:
                    print(f"Invalid field URN format: {field_urn}")
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return form_field_photos

def photos_filter_by_ids(tok: str, project_id: str, ids: List[str]) -> List[dict]:
    if not ids:
        return []
    url = f"https://developer.api.autodesk.com/construction/photos/v1/projects/{project_id}/photos:filter"
    out = []
    for i in range(0, len(ids), 50):
        body = {"filter": {"id": ids[i:i+50]}, "include": ["signedUrls"], "limit": 50}
        r = rl_request("POST", url, headers=H(tok), json=body, timeout=60)
        if r.status_code != 200:
            print(f"Failed to fetch photos: {r.status_code} - {r.text}")
            continue
        out.extend((r.json() or {}).get("results", []) or [])
    return out

def pick_best_url(signed: dict) -> Optional[str]:
    for k in ("original", "full", "large", "fileUrl", "url", "medium", "thumbnail"):
        v = (signed or {}).get(k)
        if isinstance(v, str) and v.startswith("http"):
            return v
    for v in (signed or {}).values():
        if isinstance(v, str) and v.startswith("http"):
            return v
    return None

def download_photos(photos_meta: List[dict], out_dir: str, prefix: str) -> Dict[str, str]:
    os.makedirs(out_dir, exist_ok=True)
    id2path = {}
    for p in photos_meta:
        pid = p.get("id")
        signed = p.get("signedUrls") or {}
        url = pick_best_url(signed)
        if pid and url:
            local = os.path.join(out_dir, f"{prefix}_{pid}.jpg")
            try:
                rr = rl_request("GET", url, timeout=90)
                if rr.status_code != 200:
                    print(f"Failed to download photo {pid}: HTTP {rr.status_code}")
                    continue
                with open(local, "wb") as f:
                    f.write(rr.content)
                id2path[pid] = local
                print(f"Downloaded photo {pid} to {local}")
            except Exception as e:
                print(f"Failed to download photo {pid}: {str(e)}")
    return id2path

# -----------------------------
# --------- FORMS -------------
# -----------------------------
def get_projects(tok: str) -> List[dict]:
    # Paginate across ALL projects (no max), rate-limited
    url = f"https://developer.api.autodesk.com/project/v1/hubs/{HUB_ID}/projects"
    projects: List[dict] = []
    next_url = url
    while next_url:
        r = rl_request("GET", next_url, headers={"Authorization": f"Bearer {tok}"}, timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch projects: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        projects.extend(j.get("data", []) or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return projects

def _filter_by_formdate(forms: List[dict]) -> List[dict]:
    """Keep only forms whose formDate is within the last N days (if enabled)."""
    if not FORMDATE_LAST_N_DAYS or FORMDATE_LAST_N_DAYS <= 0:
        return forms
    cutoff = date.today() - timedelta(days=FORMDATE_LAST_N_DAYS)
    out = []
    for f in forms:
        fd = f.get("formDate")
        try:
            d = date.fromisoformat(fd) if fd else None
        except Exception:
            d = None
        if d and d >= cutoff:
            out.append(f)
    return out

def list_forms_for_template(tok: str, project_id: str, template_name: str) -> List[dict]:
    # Paginate across ALL forms, then filter by template name and formDate (client-side)
    forms: List[dict] = []
    next_url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/forms"
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if r.status_code != 200:
            print(f"Failed to fetch forms for project {project_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        forms.extend(j.get("data") or j.get("results") or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")

    # Filter by template name
    matching = [f for f in forms if (f.get("formTemplate") or {}).get("name") == template_name]
    # Apply formDate window if configured
    matching = _filter_by_formdate(matching)

    print(f"Found {len(matching)} forms for template {template_name} in project {project_id} after formDate filtering")
    return matching

def get_form_templates(tok: str, project_id: str) -> List[dict]:
    url = f"https://developer.api.autodesk.com/construction/forms/v1/projects/{project_id}/form-templates?limit=50"
    out = []
    next_url = url
    while next_url:
        r = rl_request("GET", next_url, headers=H(tok), timeout=45)
        if not (200 <= r.status_code < 300):
            print(f"Failed to fetch templates for project {project_id}: {r.status_code} - {r.text}")
            break
        j = r.json() or {}
        out.extend(j.get("data") or j.get("results") or [])
        next_url = (j.get("pagination") or {}).get("nextUrl")
    return out

def template_by_id(templates: List[dict], template_id: str) -> Optional[dict]:
    for t in templates:
        if t.get("id") == template_id:
            return t
    print(f"Template {template_id} not found")
    return None

def build_value_map(custom_values: List[dict]) -> Dict[str, object]:
    vm = {}
    for cv in custom_values or []:
        iid = cv.get("itemId") or cv.get("fieldId")
        if not iid:
            continue
        if "textVal" in cv and cv["textVal"] is not None:
            vm[iid] = cv["textVal"]
        elif "multilineTextVal" in cv and cv["multilineTextVal"] is not None:
            vm[iid] = cv["multilineTextVal"]
        elif "numberVal" in cv and cv["numberVal"] is not None:
            vm[iid] = str(cv["numberVal"])
        elif "dateVal" in cv and cv["dateVal"] is not None:
            vm[iid] = cv["dateVal"]
        elif "toggleVal" in cv and cv["toggleVal"] is not None:
            vm[iid] = "Yes" if cv["toggleVal"] else "No"
        elif "choiceVal" in cv and cv["choiceVal"] is not None:
            vm[iid] = cv["choiceVal"]
        elif "multiChoiceVal" in cv and cv["multiChoiceVal"] is not None:
            vm[iid] = cv["multiChoiceVal"]
    print(f"Built value map with {len(vm)} entries: {list(vm.keys())}")
    return vm

def value_to_label(item: dict, value) -> str:
    if value is None:
        return ""
    t = item.get("type", "")
    if t == "choice":
        opts = item.get("options", []) or []
        sel = next((o for o in opts if o.get("id") == value), None)
        return (sel or {}).get("label") or "N/A"
    if t == "multi_choice":
        opts = item.get("options", []) or []
        labels = [o.get("label") for o in opts if o.get("id") in (value or [])]
        return ", ".join([x for x in labels if x]) if labels else "N/A"
    return str(value)

# -----------------------------
# --------- PDF ---------------
# -----------------------------
def make_styles():
    styles = getSampleStyleSheet()
    style_definitions = [
        {
            'name': 'Title',
            'parent': styles.get('Heading1', styles['Normal']),
            'alignment': 1,
            'fontSize': 18,
            'textColor': colors.HexColor("#0055A4"),
            'spaceAfter': 18
        },
        {
            'name': 'SectionHeader',
            'parent': styles.get('Heading2', styles['Normal']),
            'fontSize': 14,
            'textColor': colors.HexColor("#0055A4"),
            'spaceAfter': 10,
            'leading': 16
        },
        {
            'name': 'FormName',  # centered form name line
            'parent': styles.get('Heading2', styles['Normal']),
            'alignment': 1,
            'fontSize': 14,
            'textColor': colors.HexColor("#0055A4"),
            'spaceAfter': 10,
            'leading': 16
        },
        {
            'name': 'CenteredAddress',
            'parent': styles.get('Normal', styles['Normal']),
            'alignment': 1,
            'fontSize': 10,
            'leading': 12,
            'spaceAfter': 6
        },
        {
            'name': 'BodySmall',
            'parent': styles.get('Normal', styles['Normal']),
            'fontSize': 10,
            'leading': 12,
            'spaceAfter': 4
        }
    ]
    for style_def in style_definitions:
        style_name = style_def['name']
        if style_name not in styles.byName and style_name not in styles.byAlias:
            try:
                styles.add(ParagraphStyle(**style_def))
                print(f"Successfully added style: {style_name}")
            except Exception as e:
                print(f"Failed to add style {style_name}: {str(e)}")
        else:
            print(f"Style {style_name} already exists, using existing style")
    return styles

def render_form_pdf(
    project_name: str,
    project_address: str,
    form: dict,
    template: dict,
    field_photo_paths: Dict[str, List[str]],
    ref_photo_paths: List[str],
    out_path: str,
    page_decorator=None,   # draws logo/header/footer per page
) -> None:
    doc = SimpleDocTemplate(out_path, pagesize=A4, rightMargin=36, leftMargin=36, topMargin=36, bottomMargin=36)
    styles = make_styles()
    story = []

    # Header
    story.append(Paragraph(project_name, styles["Title"]))
    story.append(Paragraph(project_address or "No address available", styles["CenteredAddress"]))
    story.append(Paragraph(f"Form #{form.get('formNum', '')}: {FORM_TEMPLATE_NAME}", styles["FormName"]))
    story.append(Spacer(1, 8))

    # Form Table
    vm = build_value_map(form.get("customValues") or [])
    data = []
    section_rows: List[int] = []
    sections = (template or {}).get("sections") or []

    if not sections:
        print(f"No sections found for form {form.get('id')}, using custom values")
        current_section = None
        for cv in (form.get("customValues") or []):
            sec_label = cv.get("sectionLabel") or "Section"
            if sec_label != current_section:
                data.append([Paragraph(f"<b>{sec_label}</b>", styles["SectionHeader"]), "", ""])
                section_rows.append(len(data) - 1)
                current_section = sec_label
            item_id = cv.get("itemId") or cv.get("fieldId")
            item_label = cv.get("itemLabel") or "Item"
            val = (
                cv.get("textVal") or cv.get("multilineTextVal") or cv.get("numberVal")
                or cv.get("dateVal") or ("Yes" if cv.get("toggleVal") else "No" if "toggleVal" in cv else "")
            )
            data.append([
                Paragraph(f"<b>{item_label}</b>", styles["BodySmall"]),   # IDs removed
                Paragraph(str(val or ""), styles["BodySmall"]),
                ""
            ])
            if item_id in field_photo_paths:
                print(f"Found {len(field_photo_paths[item_id])} formfield photos for field {item_id}")
                for photo_path in field_photo_paths.get(item_id, []):
                    if isinstance(photo_path, str) and photo_path and os.path.exists(photo_path):
                        try:
                            img = Image(photo_path, width=IMG_COL_W, height=IMG_COL_W, kind='bound')
                            if data:
                                data[-1][2] = img
                            print(f"Added formfield photo {photo_path} for field {item_id}")
                        except Exception as e:
                            data[-1][2] = Paragraph(f"(formfield image failed: {str(e)})", styles["BodySmall"])
                            print(f"Failed to add formfield photo {photo_path} for field {item_id}: {str(e)}")
                    else:
                        data[-1][2] = Paragraph("(formfield image unavailable)", styles["BodySmall"])
                        print(f"Invalid or missing photo path {photo_path} for field {item_id}")
    else:
        print(f"Found {len(sections)} sections for form {form.get('id')}")
        for sec in sections:
            s_code = sec.get("code") or ""
            s_label = sec.get("label") or ""
            header_txt = (s_code + " " + s_label).strip()
            if header_txt:
                data.append([Paragraph(f"<b>{header_txt}</b>", styles["SectionHeader"]), "", ""])
                section_rows.append(len(data) - 1)
            for item in (sec.get("items") or []):
                t = item.get("type")
                if t in ("header", "label"):
                    txt = ((item.get("code") or "") + " " + (item.get("label") or "")).strip()
                    data.append([Paragraph(f"<b>{txt}</b>", styles["BodySmall"]), "", ""])
                    section_rows.append(len(data) - 1)
                    continue
                iid = item.get("id")
                val = vm.get(iid, None)
                val_str = value_to_label(item, val) if val is not None else ""
                label = ((item.get("code") or "") + " " + (item.get("label") or "")).strip()
                data.append([
                    Paragraph(f"<b>{label}</b>", styles["BodySmall"]),  # IDs removed
                    Paragraph(val_str, styles["BodySmall"]),
                    ""
                ])
                if iid in field_photo_paths:
                    print(f"Found {len(field_photo_paths[iid])} formfield photos for field {iid}")
                    for photo_path in field_photo_paths.get(iid, []):
                        if isinstance(photo_path, str) and photo_path and os.path.exists(photo_path):
                            try:
                                img = Image(photo_path, width=IMG_COL_W, height=IMG_COL_W, kind='bound')
                                if data:
                                    data[-1][2] = img
                                print(f"Added formfield photo {photo_path} for field {iid}")
                            except Exception as e:
                                data[-1][2] = Paragraph(f"(formfield image failed: {str(e)})", styles["BodySmall"])
                                print(f"Failed to add formfield photo {photo_path} for field {iid}: {str(e)}")
                        else:
                            data[-1][2] = Paragraph("(formfield image unavailable)", styles["BodySmall"])
                            print(f"Invalid or missing photo path {photo_path} for field {iid}")
   
    table = Table(data, colWidths=[TEXT_COL_W, TEXT_COL_W, IMG_COL_W])

    tbl_styles = [
        ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
        ("VALIGN", (0, 0), (-1, -1), "TOP"),
        ("PADDING", (0, 0), (-1, -1), 6),
        ("FONTNAME", (0, 0), (-1, -1), "Helvetica"),
        ("FONTSIZE", (0, 0), (-1, -1), 10),
        ("VALIGN", (2, 0), (2, -1), "MIDDLE"),
        ("ALIGN",  (2, 0), (2, -1), "CENTER"),
    ]
    for r in section_rows:
        tbl_styles.append(("SPAN", (0, r), (-1, r)))

    table.setStyle(TableStyle(tbl_styles))
    story.append(table)
    story.append(Spacer(1, 12))

    # Referenced Photos Grid
    story.append(Paragraph("Referenced Photos", styles["SectionHeader"]))
    if ref_photo_paths:
        print(f"Found {len(ref_photo_paths)} referenced photos for form {form.get('id')}")
        cols = 3
        cell_w = (A4[0] - (36 + 36) - (cols - 1) * 6) / cols
        rows = []
        row = []
        for i, p in enumerate(ref_photo_paths, 1):
            try:
                row.append(Image(p, width=cell_w, height=cell_w, kind='bound'))
                print(f"Added referenced photo {p}")
            except Exception as e:
                row.append(Paragraph(f"(referenced image failed: {str(e)})", styles["BodySmall"]))
                print(f"Failed to add referenced photo {p}: {str(e)}")
            if i % cols == 0:
                rows.append(row)
                row = []
        if row:
            while len(row) < cols:
                row.append("")
            rows.append(row)
        grid = Table(rows, colWidths=[cell_w] * cols, hAlign="LEFT")
        grid.setStyle(TableStyle([
            ("GRID", (0, 0), (-1, -1), 0.25, colors.lightgrey),
            ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
            ("ALIGN", (0, 0), (-1, -1), "CENTER"),
            ("PADDING", (0, 0), (-1, -1), 4),
        ]))
        story.append(grid)
    else:
        story.append(Paragraph("<i>No referenced photos for this form.</i>", styles["BodySmall"]))
        print(f"No referenced photos for form {form.get('id')}")

    if page_decorator:
        doc.build(story, onFirstPage=page_decorator, onLaterPages=page_decorator)
    else:
        doc.build(story)

# -----------------------------
# ------------ MAIN -----------
# -----------------------------
def list_forms_for_all_projects(tok: str) -> List[dict]:
    """Utility to list all (project, forms) pairs after template+formDate filtering."""
    addr_map = get_project_addresses(tok)
    results = []
    projects = get_projects(tok)
    if not projects:
        print("No projects found.")
        return results

    for p in projects:
        raw_id = p.get("id") or ""
        project_id = raw_id.replace("b.", "") if raw_id.startswith("b.") else raw_id
        project_name = (p.get("attributes") or {}).get("name") or project_id
        project_address = addr_map.get(project_id, "No address available")
        forms = list_forms_for_template(tok, project_id, FORM_TEMPLATE_NAME)
        if not forms:
            print(f"No forms found for {FORM_TEMPLATE_NAME} in project {project_id}")
            continue
        results.append((project_id, project_name, project_address, forms))
    return results

def main():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    tok = get_access_token()

    logo_path = choose_logo_path_from_config()
    page_logo_draw = make_page_logo_drawer(logo_path) if logo_path else None
    if logo_path:
        print(f"Using logo: {logo_path}")

    produced_pdfs = []
    photo_paths_to_clean = set()

    # Gather forms across all projects (after template + formDate filtering)
    proj_forms = list_forms_for_all_projects(tok)
    # Pre-fetch relationships once per project (for all forms in that project)
    for project_id, project_name, project_address, forms in proj_forms:
        form_field_photos = rel_formfield_to_photos(tok, project_id)
        templates = get_form_templates(tok, project_id)

        for form in forms:
            form_id = form.get("id")
            if not form_id:
                continue

            # referenced photos
            ref_photo_ids = rel_form_to_photos(tok, project_id, form_id)
            ref_photo_meta = photos_filter_by_ids(tok, project_id, ref_photo_ids) if ref_photo_ids else []
            ref_photo_map = download_photos(ref_photo_meta, OUTPUT_DIR, f"ref_{form_id}")
            ref_photo_paths = [ref_photo_map[pid] for pid in ref_photo_ids if pid in ref_photo_map]
            photo_paths_to_clean.update(ref_photo_paths)

            # formfield photos
            field_photos = form_field_photos.get(form_id, {})
            field_photo_ids = []
            for photos in field_photos.values():
                field_photo_ids.extend(photos)
            field_photo_ids = list(dict.fromkeys(field_photo_ids))  # dedupe
            field_photo_meta = photos_filter_by_ids(tok, project_id, field_photo_ids) if field_photo_ids else []
            field_photo_map = download_photos(field_photo_meta, OUTPUT_DIR, f"field_{form_id}")
            photo_paths_to_clean.update(field_photo_map.values())
            field_photo_paths = {field_id: [field_photo_map.get(pid) for pid in photos if pid in field_photo_map]
                                 for field_id, photos in field_photos.items()}

            tmpl_id = (form.get("formTemplate") or {}).get("id")
            tmpl = template_by_id(templates, tmpl_id) if tmpl_id else None

            safe_proj = "".join(c if c.isalnum() or c in (" ", "-", "_") else "_" for c in project_name).strip()
            out_pdf = os.path.join(OUTPUT_DIR, f"{safe_proj}_{form_id}.pdf")

            render_form_pdf(
                project_name=project_name,
                project_address=project_address,
                form=form,
                template=tmpl or {},
                field_photo_paths=field_photo_paths,
                ref_photo_paths=ref_photo_paths,
                out_path=out_pdf,
                page_decorator=page_logo_draw,  # draw logo on every page
            )
            produced_pdfs.append(out_pdf)
            print(f"Generated PDF for form {form_id} with {len(field_photo_ids)} formfield photos and {len(ref_photo_paths)} referenced photos")

    if produced_pdfs:
        merger = PdfMerger()
        for pdf in produced_pdfs:
            try:
                merger.append(pdf)
            except Exception as e:
                print(f"Failed to merge PDF {pdf}: {str(e)}")
        combined_path = os.path.join(OUTPUT_DIR, COMBINED_PDF_NAME)
        merger.write(combined_path)
        merger.close()
        print(f"Combined PDF saved: {combined_path}")
    else:
        print("No form PDFs produced.")

    # cleanup temp photos
    for pth in photo_paths_to_clean:
        try:
            if os.path.exists(pth):
                os.remove(pth)
                print(f"Cleaned up temporary file: {pth}")
        except Exception as e:
            print(f"Failed to clean up {pth}: {str(e)}")

if __name__ == "__main__":
    main()
